<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>Model Checking in Haskell, Part 1: Transition Systems and Invariants</title>
  <style>
    html {
      line-height: 1.5;
      font-family: Georgia, serif;
      font-size: 20px;
      color: #1a1a1a;
      background-color: #fdfdfd;
    }
    body {
      margin: 0 auto;
      max-width: 36em;
      padding-left: 50px;
      padding-right: 50px;
      padding-top: 50px;
      padding-bottom: 50px;
      hyphens: auto;
      word-wrap: break-word;
      text-rendering: optimizeLegibility;
      font-kerning: normal;
    }
    @media (max-width: 600px) {
      body {
        font-size: 0.9em;
        padding: 1em;
      }
    }
    @media print {
      body {
        background-color: transparent;
        color: black;
        font-size: 12pt;
      }
      p, h2, h3 {
        orphans: 3;
        widows: 3;
      }
      h2, h3, h4 {
        page-break-after: avoid;
      }
    }
    p {
      margin: 1em 0;
    }
    a {
      color: #1a1a1a;
    }
    a:visited {
      color: #1a1a1a;
    }
    img {
      max-width: 100%;
    }
    h1, h2, h3, h4, h5, h6 {
      margin-top: 1.4em;
    }
    h5, h6 {
      font-size: 1em;
      font-style: italic;
    }
    h6 {
      font-weight: normal;
    }
    ol, ul {
      padding-left: 1.7em;
      margin-top: 1em;
    }
    li > ol, li > ul {
      margin-top: 0;
    }
    blockquote {
      margin: 1em 0 1em 1.7em;
      padding-left: 1em;
      border-left: 2px solid #e6e6e6;
      color: #606060;
    }
    code {
      font-family: Menlo, Monaco, 'Lucida Console', Consolas, monospace;
      font-size: 85%;
      margin: 0;
    }
    pre {
      margin: 1em 0;
      overflow: auto;
    }
    pre code {
      padding: 0;
      overflow: visible;
    }
    .sourceCode {
     background-color: transparent;
     overflow: visible;
    }
    hr {
      background-color: #1a1a1a;
      border: none;
      height: 1px;
      margin: 1em 0;
    }
    table {
      margin: 1em 0;
      border-collapse: collapse;
      width: 100%;
      overflow-x: auto;
      display: block;
      font-variant-numeric: lining-nums tabular-nums;
    }
    table caption {
      margin-bottom: 0.75em;
    }
    tbody {
      margin-top: 0.5em;
      border-top: 1px solid #1a1a1a;
      border-bottom: 1px solid #1a1a1a;
    }
    th {
      border-top: 1px solid #1a1a1a;
      padding: 0.25em 0.5em 0.25em 0.5em;
    }
    td {
      padding: 0.125em 0.5em 0.25em 0.5em;
    }
    header {
      margin-bottom: 4em;
      text-align: center;
    }
    #TOC li {
      list-style: none;
    }
    #TOC a:not(:hover) {
      text-decoration: none;
    }
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    span.underline{text-decoration: underline;}
    div.column{display: inline-block; vertical-align: top; width: 50%;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    ul.task-list{list-style: none;}
    pre > code.sourceCode { white-space: pre; position: relative; }
    pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
    pre > code.sourceCode > span:empty { height: 1.2em; }
    .sourceCode { overflow: visible; }
    code.sourceCode > span { color: inherit; text-decoration: inherit; }
    div.sourceCode { margin: 1em 0; }
    pre.sourceCode { margin: 0; }
    @media screen {
    div.sourceCode { overflow: auto; }
    }
    @media print {
    pre > code.sourceCode { white-space: pre-wrap; }
    pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
    }
    pre.numberSource code
      { counter-reset: source-line 0; }
    pre.numberSource code > span
      { position: relative; left: -4em; counter-increment: source-line; }
    pre.numberSource code > span > a:first-child::before
      { content: counter(source-line);
        position: relative; left: -1em; text-align: right; vertical-align: baseline;
        border: none; display: inline-block;
        -webkit-touch-callout: none; -webkit-user-select: none;
        -khtml-user-select: none; -moz-user-select: none;
        -ms-user-select: none; user-select: none;
        padding: 0 4px; width: 4em;
        color: #aaaaaa;
      }
    pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
    div.sourceCode
      {   }
    @media screen {
    pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
    }
    code span.al { color: #ff0000; font-weight: bold; } /* Alert */
    code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
    code span.at { color: #7d9029; } /* Attribute */
    code span.bn { color: #40a070; } /* BaseN */
    code span.bu { } /* BuiltIn */
    code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
    code span.ch { color: #4070a0; } /* Char */
    code span.cn { color: #880000; } /* Constant */
    code span.co { color: #60a0b0; font-style: italic; } /* Comment */
    code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
    code span.do { color: #ba2121; font-style: italic; } /* Documentation */
    code span.dt { color: #902000; } /* DataType */
    code span.dv { color: #40a070; } /* DecVal */
    code span.er { color: #ff0000; font-weight: bold; } /* Error */
    code span.ex { } /* Extension */
    code span.fl { color: #40a070; } /* Float */
    code span.fu { color: #06287e; } /* Function */
    code span.im { } /* Import */
    code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
    code span.kw { color: #007020; font-weight: bold; } /* Keyword */
    code span.op { color: #666666; } /* Operator */
    code span.ot { color: #007020; } /* Other */
    code span.pp { color: #bc7a00; } /* Preprocessor */
    code span.sc { color: #4070a0; } /* SpecialChar */
    code span.ss { color: #bb6688; } /* SpecialString */
    code span.st { color: #4070a0; } /* String */
    code span.va { color: #19177c; } /* Variable */
    code span.vs { color: #4070a0; } /* VerbatimString */
    code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
    .display.math{display: block; text-align: center; margin: 0.5rem auto;}
  </style>
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
<header id="title-block-header">
<h1 class="title">Model Checking in Haskell, Part 1: Transition Systems and Invariants</h1>
</header>
<p>I’ve been reading a <a href="https://www.amazon.com/Principles-Model-Checking-MIT-Press/dp/026202649X/ref=sr_1_1?crid=2RGC1B0N79HIJ&amp;keywords=principles+of+model+checking&amp;qid=1651762001&amp;sprefix=principles+of+model+checking%2Caps%2C134&amp;sr=8-1">book</a> and watching a <a href="https://www.youtube.com/watch?v=Y5Hg4MvUXc4&amp;list=PLwabKnOFhE38C0o6z_bhlF_uOUlblDTjh">lecture series</a> about model checking. This is a topic I’ve learned a bit about in the past, but never really studied in earnest.</p>
<p>In model checking, we create a <em>model</em> of some sort of stateful artifact, like a computer program, sequential circuit, or even something in the “real world” (like a vending machine or traffic light). Then, we state a <em>property</em> we would like to hold about <em>all possible behaviors</em> of the model. Finally, we check whether this property holds for the model, using a variety of nifty algorithms.</p>
<p>This series of blog posts constitutes a brief and very high-level introduction to model checking, using Haskell code to express the ideas and implement the algorithms. The intended audience is anyone who knows a bit of Haskell, and who wants to understand what model checking is all about.</p>
<p>This post was generated with <code>pandoc</code> from a <a href="https://github.com/benjaminselfridge/model-checking/blob/master/src/ModelChecking1.lhs">literate haskell document</a>.</p>
<p>Preamble:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">module</span> <span class="dt">ModelChecking1</span> <span class="kw">where</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Data.List</span> (nubBy, find)</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Data.Word</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">System.Random</span> (<span class="dt">RandomGen</span>, randomR)</span></code></pre></div>
<h2 id="overview">Overview</h2>
<p>In this post, we will introduce the notion of a transition system, and we will state simple properties about them, called <em>invariants</em>. We will also implement a simple model checking algorithm, whose aim is to check that an invariant holds for all reachable states of the system.</p>
<h2 id="transition-systems">Transition systems</h2>
<p>Let <code>s</code>, <code>action</code>, and <code>ap</code> be arbitrary Haskell types. Then a <em>transition system</em> over state set <code>s</code>, action set <code>action</code>, and atomic propositions <code>ap</code> is defined as follows:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">TransitionSystem</span> s action ap <span class="ot">=</span> <span class="dt">TransitionSystem</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>  {<span class="ot"> tsInitialStates ::</span> [s]</span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>  ,<span class="ot"> tsLabel         ::</span> s <span class="ot">-&gt;</span> [ap]</span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a>  ,<span class="ot"> tsTransitions   ::</span> s <span class="ot">-&gt;</span> [(action, s)]</span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a>  }</span></code></pre></div>
<p>The intuition behind each of the three fields of a transition system <code>ts</code> is as follows:</p>
<ul>
<li><code>tsInitialStates ts</code>: “the states that the system can start in”</li>
<li><code>tsLabel ts s</code>: “the set of all atomic propositions that are true in state <code>s</code>”</li>
<li><code>tsTransitions ts s</code>: “all of <code>s</code>’s outgoing transitions”</li>
</ul>
<p>The label of a state is an abstraction of the “internal data” of that state, and the transitions are an abstraction of control flow. Here, a transition is a pair <code>(action, s')</code> where <code>s'</code> is the destination state of the transition, and <code>action</code> is a name for the transition.</p>
<h2 id="example-traffic-light">Example: Traffic light</h2>
<p>We can create a very simple transition system representing the states and transitions of a traffic light. The states <code>s</code> will be the colors red, yellow, and green:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Color</span> <span class="ot">=</span> <span class="dt">Red</span> <span class="op">|</span> <span class="dt">Yellow</span> <span class="op">|</span> <span class="dt">Green</span> <span class="kw">deriving</span> (<span class="dt">Show</span>, <span class="dt">Eq</span>, <span class="dt">Ord</span>)</span></code></pre></div>
<p>There will only be one action:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">ChangeColor</span> <span class="ot">=</span> <span class="dt">ChangeColor</span> <span class="kw">deriving</span> (<span class="dt">Show</span>, <span class="dt">Eq</span>, <span class="dt">Ord</span>)</span></code></pre></div>
<p>Finally, our set of transitions will allow <code>Red</code> to transition to <code>Green</code>, <code>Green</code> to <code>Yellow</code>, and <code>Yellow</code> to <code>Red</code>:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="ot">traffic_light ::</span> <span class="dt">TransitionSystem</span> <span class="dt">Color</span> <span class="dt">ChangeColor</span> <span class="dt">Color</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>traffic_light <span class="ot">=</span> <span class="dt">TransitionSystem</span></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a>  { tsInitialStates <span class="ot">=</span> [<span class="dt">Red</span>]</span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a>  , tsLabel <span class="ot">=</span> \s <span class="ot">-&gt;</span> [s]</span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a>  , tsTransitions <span class="ot">=</span> \s <span class="ot">-&gt;</span> <span class="kw">case</span> s <span class="kw">of</span></span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a>      <span class="dt">Red</span>    <span class="ot">-&gt;</span> [(<span class="dt">ChangeColor</span>, <span class="dt">Green</span> )]</span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true" tabindex="-1"></a>      <span class="dt">Green</span>  <span class="ot">-&gt;</span> [(<span class="dt">ChangeColor</span>, <span class="dt">Yellow</span>)]</span>
<span id="cb5-8"><a href="#cb5-8" aria-hidden="true" tabindex="-1"></a>      <span class="dt">Yellow</span> <span class="ot">-&gt;</span> [(<span class="dt">ChangeColor</span>, <span class="dt">Red</span>   )]</span>
<span id="cb5-9"><a href="#cb5-9" aria-hidden="true" tabindex="-1"></a>  }</span></code></pre></div>
<p>Notice that we reuse our state type <code>Color</code> as our set of atomic propositions. The label of each state <code>s</code> is <code>[s]</code>: the only color that is on in state <code>s</code> is <code>s</code> itself. We can check this in <code>ghci</code>:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a>  <span class="op">&gt;</span> tsLabel traffic_light <span class="dt">Red</span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a>  [<span class="dt">Red</span>]</span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a>  <span class="op">&gt;</span> tsLabel traffic_light <span class="dt">Yellow</span></span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a>  [<span class="dt">Yellow</span>]</span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a>  <span class="op">&gt;</span> tsLabel traffic_light <span class="dt">Green</span></span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a>  [<span class="dt">Green</span>]</span></code></pre></div>
<h2 id="running-a-transition-system">“Running” a transition system</h2>
<p>A <em>run</em> of a transition system is a finite or infinite path in the underlying graph:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Path</span> s action <span class="ot">=</span> <span class="dt">Path</span> s [(action, s)]</span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">deriving</span> (<span class="dt">Show</span>)</span></code></pre></div>
<p>In the transitions systems we’ll define, it will be useful to be able to examine random infinite runs of the system to get a feel for what the possibilites are:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="ot">randomRun ::</span> <span class="dt">RandomGen</span> g <span class="ot">=&gt;</span> g <span class="ot">-&gt;</span> <span class="dt">TransitionSystem</span> s action ap <span class="ot">-&gt;</span> <span class="dt">Path</span> s action</span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a>randomRun g ts <span class="ot">=</span> <span class="kw">let</span> (i, g&#39;) <span class="ot">=</span> randomR (<span class="dv">0</span>, <span class="fu">length</span> (tsInitialStates ts)) g</span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a>                     s <span class="ot">=</span> tsInitialStates ts <span class="op">!!</span> i</span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a>                 <span class="kw">in</span> <span class="dt">Path</span> s (randomRun&#39; g&#39; s ts)</span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a>  <span class="kw">where</span> randomRun&#39; g s ts <span class="ot">=</span> <span class="kw">let</span> nexts <span class="ot">=</span> tsTransitions ts s</span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true" tabindex="-1"></a>                                (i, g&#39;) <span class="ot">=</span> randomR (<span class="dv">0</span>, <span class="fu">length</span> nexts <span class="op">-</span> <span class="dv">1</span>) g</span>
<span id="cb8-7"><a href="#cb8-7" aria-hidden="true" tabindex="-1"></a>                                (action, s&#39;) <span class="ot">=</span> nexts <span class="op">!!</span> i</span>
<span id="cb8-8"><a href="#cb8-8" aria-hidden="true" tabindex="-1"></a>                            <span class="kw">in</span> (action, s&#39;) <span class="op">:</span> randomRun&#39; g s&#39; ts</span></code></pre></div>
<p>We also define a version of <code>take</code> that works on infinite <code>Path</code>s, so that we can easily look at finite prefixes:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="ot">takePath ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Path</span> s action <span class="ot">-&gt;</span> <span class="dt">Path</span> s action</span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a>takePath n (<span class="dt">Path</span> s transitions) <span class="ot">=</span> <span class="dt">Path</span> s (<span class="fu">take</span> n transitions)</span></code></pre></div>
<p>We can put this function to the test on our <code>traffic_light</code> example in <code>ghci</code>:</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a>  <span class="op">&gt;</span> <span class="kw">import</span> <span class="dt">System.Random</span></span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a>  <span class="op">&gt;</span> g <span class="ot">=</span> mkStdGen <span class="dv">0</span></span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a>  <span class="op">&gt;</span> takePath <span class="dv">6</span> (randomRun g traffic_light)</span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Path</span> <span class="dt">Red</span> [(<span class="dt">ChangeColor</span>,<span class="dt">Green</span>),(<span class="dt">ChangeColor</span>,<span class="dt">Yellow</span>),(<span class="dt">ChangeColor</span>,<span class="dt">Red</span>),(<span class="dt">ChangeColor</span>,<span class="dt">Green</span>),(<span class="dt">ChangeColor</span>,<span class="dt">Yellow</span>),(<span class="dt">ChangeColor</span>,<span class="dt">Red</span>)]</span></code></pre></div>
<p>Because each state in <code>traffic_light</code> has exactly one outgoing transition, this is the only run we will ever get. In subsequent posts, we’ll look at nondeterministic transition systems which will return different runs with different random generators.</p>
<p>The following two functions will be useful to have:</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="ot">singletonPath ::</span> s <span class="ot">-&gt;</span> <span class="dt">Path</span> s action</span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a>singletonPath s <span class="ot">=</span> <span class="dt">Path</span> s []</span></code></pre></div>
<div class="sourceCode" id="cb12"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="ot">consPath ::</span> (s, action) <span class="ot">-&gt;</span> <span class="dt">Path</span> s action <span class="ot">-&gt;</span> <span class="dt">Path</span> s action</span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a>consPath (s, action) (<span class="dt">Path</span> s&#39; tl) <span class="ot">=</span> <span class="dt">Path</span> s ((action, s&#39;)<span class="op">:</span>tl)</span></code></pre></div>
<div class="sourceCode" id="cb13"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span class="ot">reversePath ::</span> <span class="dt">Path</span> s action <span class="ot">-&gt;</span> <span class="dt">Path</span> s action</span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a>reversePath (<span class="dt">Path</span> s prefix) <span class="ot">=</span> go [] s prefix</span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">where</span> go suffix s [] <span class="ot">=</span> <span class="dt">Path</span> s suffix</span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true" tabindex="-1"></a>        go suffix s ((action, s&#39;)<span class="op">:</span>prefix) <span class="ot">=</span> go ((action, s)<span class="op">:</span>suffix) s&#39; prefix</span></code></pre></div>
<h2 id="propositions">Propositions</h2>
<p>We are interested in checking properties about the states of a transition system. For this, we will need the notion of a <em>proposition</em>:</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">Proposition</span> ap <span class="ot">=</span> [ap] <span class="ot">-&gt;</span> <span class="dt">Bool</span></span></code></pre></div>
<p>The <code>ap</code> type represents our atomic propositional variables, and a list <code>[ap]</code> is thought of as “the set of variables that are true”. In this sense, a <code>Proposition</code> can represent any logical formula over the variables <code>ap</code>.</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a><span class="ot">(|=) ::</span> [a] <span class="ot">-&gt;</span> <span class="dt">Proposition</span> a <span class="ot">-&gt;</span> <span class="dt">Bool</span></span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a>a <span class="op">|=</span> p <span class="ot">=</span> p a</span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true" tabindex="-1"></a>infix <span class="dv">0</span> <span class="op">|=</span></span></code></pre></div>
<p><code>a |= p</code> is read as “a satisfies p”. A very simple predicate is <code>true</code>, which holds for all inputs:</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a><span class="ot">true ::</span> <span class="dt">Proposition</span> a</span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a>true _ <span class="ot">=</span> <span class="dt">True</span></span></code></pre></div>
<p>Similarly, <code>false</code> holds for no inputs:</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a><span class="ot">false ::</span> <span class="dt">Proposition</span> a</span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a>false _ <span class="ot">=</span> <span class="dt">False</span></span></code></pre></div>
<p>Given an atomic propositional variable <code>ap</code>, we can form the proposition “<code>ap</code> holds” as follows:</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a><span class="ot">atom ::</span> <span class="dt">Eq</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Proposition</span> a</span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a>atom a as <span class="ot">=</span> a <span class="ot">`elem`</span> as</span></code></pre></div>
<p>We can define the usual boolean operators on predicates in terms of satisfaction:</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a><span class="ot">(.&amp;) ::</span> <span class="dt">Proposition</span> a <span class="ot">-&gt;</span> <span class="dt">Proposition</span> a <span class="ot">-&gt;</span> <span class="dt">Proposition</span> a</span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true" tabindex="-1"></a>(p <span class="op">.&amp;</span> q) a <span class="ot">=</span> p a <span class="op">&amp;&amp;</span> q a</span>
<span id="cb19-3"><a href="#cb19-3" aria-hidden="true" tabindex="-1"></a><span class="kw">infixr</span> <span class="dv">3</span> <span class="op">.&amp;</span></span>
<span id="cb19-4"><a href="#cb19-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-5"><a href="#cb19-5" aria-hidden="true" tabindex="-1"></a><span class="ot">(.|) ::</span> <span class="dt">Proposition</span> a <span class="ot">-&gt;</span> <span class="dt">Proposition</span> a <span class="ot">-&gt;</span> <span class="dt">Proposition</span> a</span>
<span id="cb19-6"><a href="#cb19-6" aria-hidden="true" tabindex="-1"></a>(p <span class="op">.|</span> q) a <span class="ot">=</span> p a <span class="op">||</span> q a</span>
<span id="cb19-7"><a href="#cb19-7" aria-hidden="true" tabindex="-1"></a><span class="kw">infixr</span> <span class="dv">2</span> <span class="op">.|</span></span>
<span id="cb19-8"><a href="#cb19-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-9"><a href="#cb19-9" aria-hidden="true" tabindex="-1"></a><span class="ot">pnot ::</span> <span class="dt">Proposition</span> a <span class="ot">-&gt;</span> <span class="dt">Proposition</span> a</span>
<span id="cb19-10"><a href="#cb19-10" aria-hidden="true" tabindex="-1"></a>pnot p a <span class="ot">=</span> <span class="fu">not</span> (p a)</span>
<span id="cb19-11"><a href="#cb19-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-12"><a href="#cb19-12" aria-hidden="true" tabindex="-1"></a><span class="ot">(.-&gt;) ::</span> <span class="dt">Proposition</span> a <span class="ot">-&gt;</span> <span class="dt">Proposition</span> a <span class="ot">-&gt;</span> <span class="dt">Proposition</span> a</span>
<span id="cb19-13"><a href="#cb19-13" aria-hidden="true" tabindex="-1"></a>(p <span class="op">.-&gt;</span> q) a <span class="ot">=</span> <span class="kw">if</span> p a <span class="kw">then</span> q a <span class="kw">else</span> <span class="dt">True</span></span>
<span id="cb19-14"><a href="#cb19-14" aria-hidden="true" tabindex="-1"></a><span class="kw">infixr</span> <span class="dv">1</span> <span class="op">.-&gt;</span></span></code></pre></div>
<h2 id="checking-invariants">Checking invariants</h2>
<p>Given a transition system <code>ts</code> and a proposition <code>p</code>, we can ask: “Does <code>p</code> hold at all reachable states in <code>ts</code>?” A proposition which is supposed to hold at all reachable states of a transition system is called an <em>invariant</em>.</p>
<p>To check whether an invariant holds, we evaluate the proposition on each reachable state (more precisely, on the <em>label</em> of each state). To do this, we define a lazy breadth-first search of the transition system, which discovers all reachable states and provides a path to each one it finds. We’ll first need a simple queue data structure:</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">Q</span> a <span class="ot">=</span> ([a], [a])</span></code></pre></div>
<div class="sourceCode" id="cb21"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a><span class="ot">deq ::</span> <span class="dt">Q</span> a <span class="ot">-&gt;</span> <span class="dt">Maybe</span> (a, <span class="dt">Q</span> a)</span>
<span id="cb21-2"><a href="#cb21-2" aria-hidden="true" tabindex="-1"></a>deq ([], []) <span class="ot">=</span> <span class="dt">Nothing</span></span>
<span id="cb21-3"><a href="#cb21-3" aria-hidden="true" tabindex="-1"></a>deq (prefix, a<span class="op">:</span>suffix) <span class="ot">=</span> <span class="dt">Just</span> (a, (prefix, suffix))</span>
<span id="cb21-4"><a href="#cb21-4" aria-hidden="true" tabindex="-1"></a>deq (prefix, []) <span class="ot">=</span> deq ([], <span class="fu">reverse</span> prefix)</span></code></pre></div>
<div class="sourceCode" id="cb22"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true" tabindex="-1"></a><span class="ot">enqs ::</span> [a] <span class="ot">-&gt;</span> <span class="dt">Q</span> a <span class="ot">-&gt;</span> <span class="dt">Q</span> a</span>
<span id="cb22-2"><a href="#cb22-2" aria-hidden="true" tabindex="-1"></a>enqs as (prefix, suffix) <span class="ot">=</span> (as <span class="op">++</span> prefix, suffix)</span></code></pre></div>
<p>Now, we can implement a classic breadth-first search:</p>
<div class="sourceCode" id="cb23"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true" tabindex="-1"></a><span class="ot">bfs ::</span> <span class="dt">Eq</span> s <span class="ot">=&gt;</span> [s] <span class="ot">-&gt;</span> (s <span class="ot">-&gt;</span> [(action, s)]) <span class="ot">-&gt;</span> [(s, <span class="dt">Path</span> s action)]</span>
<span id="cb23-2"><a href="#cb23-2" aria-hidden="true" tabindex="-1"></a>bfs starts transitions <span class="ot">=</span></span>
<span id="cb23-3"><a href="#cb23-3" aria-hidden="true" tabindex="-1"></a>  [ (s, reversePath p) <span class="op">|</span> p<span class="op">@</span>(<span class="dt">Path</span> s tl) <span class="ot">&lt;-</span> loop [] (singletonPath <span class="op">&lt;$&gt;</span> starts, []) ]</span>
<span id="cb23-4"><a href="#cb23-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">where</span> loop visited q</span>
<span id="cb23-5"><a href="#cb23-5" aria-hidden="true" tabindex="-1"></a>          <span class="op">|</span> <span class="dt">Nothing</span> <span class="ot">&lt;-</span> deq q <span class="ot">=</span> []</span>
<span id="cb23-6"><a href="#cb23-6" aria-hidden="true" tabindex="-1"></a>          <span class="op">|</span> <span class="dt">Just</span> (<span class="dt">Path</span> s _, q&#39;) <span class="ot">&lt;-</span> deq q, s <span class="ot">`elem`</span> visited <span class="ot">=</span> loop visited q&#39;</span>
<span id="cb23-7"><a href="#cb23-7" aria-hidden="true" tabindex="-1"></a>          <span class="op">|</span> <span class="dt">Just</span> (p<span class="op">@</span>(<span class="dt">Path</span> s _), q&#39;) <span class="ot">&lt;-</span> deq q <span class="ot">=</span></span>
<span id="cb23-8"><a href="#cb23-8" aria-hidden="true" tabindex="-1"></a>              <span class="kw">let</span> nexts <span class="ot">=</span> [ consPath (s&#39;, action) p <span class="op">|</span> (action, s&#39;) <span class="ot">&lt;-</span> transitions s ]</span>
<span id="cb23-9"><a href="#cb23-9" aria-hidden="true" tabindex="-1"></a>              <span class="kw">in</span> p <span class="op">:</span> loop (s<span class="op">:</span>visited) (enqs nexts q)</span></code></pre></div>
<p>Now, to check an invariant, we simply collect all the reachable states via <code>bfs</code> and make sure the invariant holds for each of their labels, producing a path to a bad state if there is one:</p>
<div class="sourceCode" id="cb24"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb24-1"><a href="#cb24-1" aria-hidden="true" tabindex="-1"></a><span class="ot">checkInvariant ::</span> <span class="dt">Eq</span> s</span>
<span id="cb24-2"><a href="#cb24-2" aria-hidden="true" tabindex="-1"></a>               <span class="ot">=&gt;</span> <span class="dt">Proposition</span> ap</span>
<span id="cb24-3"><a href="#cb24-3" aria-hidden="true" tabindex="-1"></a>               <span class="ot">-&gt;</span> <span class="dt">TransitionSystem</span> s action ap</span>
<span id="cb24-4"><a href="#cb24-4" aria-hidden="true" tabindex="-1"></a>               <span class="ot">-&gt;</span> <span class="dt">Maybe</span> (s, <span class="dt">Path</span> s action)</span>
<span id="cb24-5"><a href="#cb24-5" aria-hidden="true" tabindex="-1"></a>checkInvariant p ts <span class="ot">=</span></span>
<span id="cb24-6"><a href="#cb24-6" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> rs <span class="ot">=</span> bfs (tsInitialStates ts) (tsTransitions ts)</span>
<span id="cb24-7"><a href="#cb24-7" aria-hidden="true" tabindex="-1"></a>  <span class="kw">in</span> find (\(s,_) <span class="ot">-&gt;</span> tsLabel ts s <span class="op">|=</span> pnot p) rs</span></code></pre></div>
<h2 id="checking-a-traffic-light-invariant">Checking a traffic light invariant</h2>
<p>Let’s check an invariant of our traffic light system – that the light is never red and green at the same time. It’s not a very interesting invariant, but it’s a good one for any traffic light to have.</p>
<p>We can use our <code>checkInvariant</code> function to check that this invariant holds:</p>
<div class="sourceCode" id="cb25"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb25-1"><a href="#cb25-1" aria-hidden="true" tabindex="-1"></a>  <span class="op">&gt;</span> checkInvariant (pnot (atom <span class="dt">Red</span> <span class="op">.&amp;</span> atom <span class="dt">Green</span>)) traffic_light</span>
<span id="cb25-2"><a href="#cb25-2" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Nothing</span></span></code></pre></div>
<p>The result <code>Nothing</code> means there were no counterexamples, which means our invariant holds! Let’s try it with an invariant that doesn’t hold:</p>
<div class="sourceCode" id="cb26"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb26-1"><a href="#cb26-1" aria-hidden="true" tabindex="-1"></a>  <span class="op">&gt;</span> checkInvariant (pnot (atom <span class="dt">Yellow</span>)) traffic_light</span>
<span id="cb26-2"><a href="#cb26-2" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Just</span> (<span class="dt">Path</span> <span class="dt">Red</span> [(<span class="dt">ChangeColor</span>,<span class="dt">Green</span>),(<span class="dt">ChangeColor</span>,<span class="dt">Yellow</span>)])</span></code></pre></div>
<p>Our invariant checking algorithm was able to find a path to a state that violated <code>not (atom Yellow)</code>; unsurprisingly, the bad state was <code>Yellow</code> (the last state in the counterexample path). Because <code>Yellow</code> is reachable in our transition system, our property doesn’t hold. What if, however, <code>Yellow</code> is not reachable?</p>
<div class="sourceCode" id="cb27"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb27-1"><a href="#cb27-1" aria-hidden="true" tabindex="-1"></a>  <span class="op">&gt;</span> traffic_light <span class="ot">=</span> <span class="dt">TransitionSystem</span> [<span class="dt">Red</span>] (<span class="op">:</span>[]) (\s <span class="ot">-&gt;</span> <span class="kw">case</span> s <span class="kw">of</span> <span class="dt">Red</span> <span class="ot">-&gt;</span> [(<span class="dt">ChangeColor</span>, <span class="dt">Green</span>)]; <span class="dt">Green</span> <span class="ot">-&gt;</span> [(<span class="dt">ChangeColor</span>, <span class="dt">Red</span>)]; <span class="dt">Yellow</span> <span class="ot">-&gt;</span> [(<span class="dt">ChangeColor</span>, <span class="dt">Red</span>)])</span>
<span id="cb27-2"><a href="#cb27-2" aria-hidden="true" tabindex="-1"></a>  <span class="op">&gt;</span> checkInvariant (pnot (atom <span class="dt">Yellow</span>)) traffic_light</span>
<span id="cb27-3"><a href="#cb27-3" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Nothing</span></span></code></pre></div>
<h2 id="conclusion">Conclusion</h2>
<p>Hopefully, this first post gave you a taste of what model checking is all about. In the next post, we’ll talk about how to convert higher-level program to transition systems, and use this machinery to look at a more complex example than the traffic light system studied in this post.</p>
</body>
</html>
