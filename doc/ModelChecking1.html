<h1 id="introduction-to-model-checking-with-haskell-part-1-checking-invariants">Introduction to model checking (with Haskell!), Part 1: checking invariants</h1>
<p>Recently, I’ve been reading a <a href="https://www.amazon.com/Principles-Model-Checking-MIT-Press/dp/026202649X/ref=sr_1_1?crid=2RGC1B0N79HIJ&amp;keywords=principles+of+model+checking&amp;qid=1651762001&amp;sprefix=principles+of+model+checking%2Caps%2C134&amp;sr=8-1">book</a> and watching a <a href="https://www.youtube.com/watch?v=Y5Hg4MvUXc4&amp;list=PLwabKnOFhE38C0o6z_bhlF_uOUlblDTjh">lecture series</a> about model checking. This is a topic I’ve learned a bit about in the past, but never really studied in earnest.</p>
<p>In model checking, we create a <em>model</em> of some sort of stateful artifact, like a computer program, sequential circuit, or even something in the “real world” (like a vending machine or traffic light). Then, we state a <em>property</em> we would like to hold about <em>all possible behaviors</em> of the model. Finally, we check whether this property holds for the model, using a variety of nifty algorithms.</p>
<p>This series of blog posts is an attempt to formalize some of the core notions and algorithms of model checking in Haskell. I hope it provides a brief and illustrative introduction for other Haskell programmers who are curious about the topic. <em>This is for learning purposes only!</em> I deliberately avoided putting any effort into making things efficient. I’m really using Haskell as a convenient executable notation to express the ideas.</p>
<p>This post is a <a href="https://github.com/benjaminselfridge/model-checking/blob/master/src/ModelChecking.lhs">literate haskell document</a>.</p>
<p>Preamble:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">module</span> <span class="dt">ModelChecking1</span> <span class="kw">where</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Data.List</span> (union, (\\), nub, find)</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Prelude</span> <span class="kw">hiding</span> (not, (*))</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Prelude</span> <span class="kw">as</span> <span class="dt">P</span></span></code></pre></div>
<h2 id="overview">Overview</h2>
<p>In this blog post, I will introduce the notion of a transition system, and we will explore how to state simple properties about them, called <em>invariants</em>. We will also implement the simplest model checking algorithm, which is to check that an invariant holds for all reachable states of the system.</p>
<h2 id="transition-systems">Transition systems</h2>
<p>So, what are these “models” we are checking? They are called <em>transition systems</em>. A transition system is a directed graph, where the vertices of the graph represent possible program states, and the edges represent transitions from one state to another. The transitions are followed nondeterministically; when a state has multiple outgoing transitions, that simply means that it can follow any of them. A transition system also has a nonempty set of <em>initial states</em>, which correspond to the beginning of a program’s execution.</p>
<p>Along with the states (vertices) and transitions (directed edges), a transition system has one additional ingredient: a set of <em>atomic propositional variables</em> that are either true or false in each state. In Haskell, we represent these variables as a type (or a type variable <code>ap</code>), and we formalize the notion of an <em>assignment</em> of variables as a function from this type to <code>Bool</code>:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">Assignment</span> ap <span class="ot">=</span> ap <span class="ot">-&gt;</span> <span class="dt">Bool</span></span></code></pre></div>
<p>It’s often convenient to “lift” a propositional variable <code>p</code> to the assignment which sets <code>p</code> to <code>True</code>, and everything else to <code>False</code>, so we define a function to accomplish this here:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="ot">only ::</span> <span class="dt">Eq</span> ap <span class="ot">=&gt;</span> ap <span class="ot">-&gt;</span> <span class="dt">Assignment</span> ap</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>only <span class="ot">=</span> (<span class="op">==</span>)</span></code></pre></div>
<p>The idea is that every state in our transition system is <em>labeled</em> with an assignment, identifying which atomic propositions are true or false in each state. We can now define a transition system in Haskell:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">TransitionSystem</span> s ap <span class="ot">=</span> <span class="dt">TransitionSystem</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>  {<span class="ot"> tsInitials ::</span> [s]</span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a>  ,<span class="ot"> tsTransitions ::</span> [(s, s)]</span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a>  ,<span class="ot"> tsLabel ::</span> s <span class="ot">-&gt;</span> <span class="dt">Assignment</span> ap</span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a>  }</span></code></pre></div>
<p>The initial states are represented as a list, the transitions as an association list (mathematically, a relation), and the labels as a function from states to <code>Assignment</code>s of the atomic propositions <code>ap</code>. As stated in the introduction, this is by no means a good representation if your goal is efficiency; the point here is to make the concepts as easy to understand as possible.</p>
<h2 id="propositions">Propositions</h2>
<p>As stated above, every state in our transition system is “labeled” with an assignment of boolean truth values to the propositional variables <code>ap</code>. We are interested in checking whether certain properties hold for our transition system. In order to to state these properties, we will need the notion of a logical proposition. I formalize this as a function that maps <code>Assignment</code>s to <code>Bool</code>s; the idea is that for a fixed <code>Assignment</code> of values to the atomic propositional variables, a proposition either holds or does not hold.</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">Proposition</span> ap <span class="ot">=</span> <span class="dt">Assignment</span> ap <span class="ot">-&gt;</span> <span class="dt">Bool</span></span></code></pre></div>
<p>With this type, we can define propositional satisfaction as function application:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="ot">(|=) ::</span> <span class="dt">Assignment</span> ap <span class="ot">-&gt;</span> <span class="dt">Proposition</span> ap <span class="ot">-&gt;</span> <span class="dt">Bool</span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a>f <span class="op">|=</span> p <span class="ot">=</span> p f</span></code></pre></div>
<p>If <code>f</code> is an assignment and <code>p</code> is a proposition, <code>f |= p</code> is read as “f satisfies p”.</p>
<p>A very simple proposition is <code>true</code>, which holds for all assignments:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="ot">true ::</span> <span class="dt">Proposition</span> ap</span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a>true _ <span class="ot">=</span> <span class="dt">True</span></span></code></pre></div>
<p>Similarly, <code>false</code> holds for no assignments:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="ot">false ::</span> <span class="dt">Proposition</span> ap</span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a>false _ <span class="ot">=</span> <span class="dt">False</span></span></code></pre></div>
<p>Given an atomic propositional variable <code>p</code>, we can form the proposition “<code>p</code> holds” as follows:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="ot">atom ::</span> ap <span class="ot">-&gt;</span> <span class="dt">Proposition</span> ap</span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a>atom ap f <span class="ot">=</span> f ap</span></code></pre></div>
<p>Given an assignment <code>f : ap -&gt; Bool</code>, <code>atom ap f</code> will be <code>True</code> if and only if <code>f</code> assigns <code>True</code> to the atomic propositional variable <code>ap</code>.</p>
<p>We can define the usual boolean operators on propositions in terms of satisfaction:</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="ot">(.&amp;) ::</span> <span class="dt">Proposition</span> ap <span class="ot">-&gt;</span> <span class="dt">Proposition</span> ap <span class="ot">-&gt;</span> <span class="dt">Proposition</span> ap</span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a>(p <span class="op">.&amp;</span> q) f <span class="ot">=</span> (f <span class="op">|=</span> p) <span class="op">&amp;&amp;</span> (f <span class="op">|=</span> q)</span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a><span class="ot">(.|) ::</span> <span class="dt">Proposition</span> ap <span class="ot">-&gt;</span> <span class="dt">Proposition</span> ap <span class="ot">-&gt;</span> <span class="dt">Proposition</span> ap</span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true" tabindex="-1"></a>(p <span class="op">.|</span> q) f <span class="ot">=</span> (f <span class="op">|=</span> p) <span class="op">||</span> (f <span class="op">|=</span> q)</span>
<span id="cb10-6"><a href="#cb10-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-7"><a href="#cb10-7" aria-hidden="true" tabindex="-1"></a><span class="fu">not</span><span class="ot"> ::</span> <span class="dt">Proposition</span> ap <span class="ot">-&gt;</span> <span class="dt">Proposition</span> ap</span>
<span id="cb10-8"><a href="#cb10-8" aria-hidden="true" tabindex="-1"></a><span class="fu">not</span> p f <span class="ot">=</span> P.not (f <span class="op">|=</span> p)</span>
<span id="cb10-9"><a href="#cb10-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-10"><a href="#cb10-10" aria-hidden="true" tabindex="-1"></a><span class="ot">(.-&gt;) ::</span> <span class="dt">Proposition</span> ap <span class="ot">-&gt;</span> <span class="dt">Proposition</span> ap <span class="ot">-&gt;</span> <span class="dt">Proposition</span> ap</span>
<span id="cb10-11"><a href="#cb10-11" aria-hidden="true" tabindex="-1"></a>p <span class="op">.-&gt;</span> q <span class="ot">=</span> <span class="fu">not</span> p <span class="op">.|</span> q</span></code></pre></div>
<p>In other words, the assignment <code>f</code> satisfies the proposition <code>p</code> and <code>q</code> whenever <code>f |= p</code> and <code>f |= q</code>; likewise for the other operators.</p>
<h2 id="checking-invariants">Checking invariants</h2>
<p>In the previous section, we defined the notion of an assignment, which is a function from variables to truth values, as well as the notion of a proposition, which either holds or does not hold for a given assignment. We can now ask a simple question of a given transition system <code>ts</code> and a given proposition <code>p</code>: “Does <code>p</code> hold at all reachable states in <code>ts</code>?” Stated in terms of the definitions above, we are asking whether, for each reachable state <code>s</code> of <code>ts</code>, whether <code>tsLabel ts s |= p</code>.</p>
<p>So, how do we check whether an invariant holds? The answer is simple: we search the underlying graph of the transition system, and evaluate the proposition on each state (more precisely, on the <em>label</em> of each state). To do this, we first define an auxiliary function that collects all reachable states in the graph.</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="ot">reachables ::</span> <span class="dt">Eq</span> s <span class="ot">=&gt;</span> [s] <span class="ot">-&gt;</span> [(s, s)] <span class="ot">-&gt;</span> [s]</span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a>reachables starts <span class="ot">=</span> go [] starts</span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">where</span> go visited [] _ <span class="ot">=</span> nub visited</span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a>        go visited starts transitions <span class="ot">=</span></span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true" tabindex="-1"></a>          <span class="kw">let</span> nexts <span class="ot">=</span> [ s&#39;&#39; <span class="op">|</span> s <span class="ot">&lt;-</span> starts, (s&#39;, s&#39;&#39;) <span class="ot">&lt;-</span> transitions, s <span class="op">==</span> s&#39; ] \\ visited</span>
<span id="cb11-6"><a href="#cb11-6" aria-hidden="true" tabindex="-1"></a>          <span class="kw">in</span> go (visited <span class="op">++</span> starts) nexts transitions</span></code></pre></div>
<p>Now, to check an invariant, we simply collect all the reachable states and make sure the invariant holds for each of their labels, producing a counterexample if there is one:</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="ot">checkInvariant ::</span> <span class="dt">Eq</span> s <span class="ot">=&gt;</span> <span class="dt">Proposition</span> ap <span class="ot">-&gt;</span> <span class="dt">TransitionSystem</span> s ap <span class="ot">-&gt;</span> <span class="dt">Maybe</span> s</span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a>checkInvariant p ts <span class="ot">=</span></span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> rs <span class="ot">=</span> reachables (tsInitials ts) (tsTransitions ts)</span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">in</span> find (\s <span class="ot">-&gt;</span> tsLabel ts s <span class="op">|=</span> <span class="fu">not</span> p) rs</span></code></pre></div>
<p>Let’s fire up ghci and check our first model! The model will be a single traffic light, and we will make sure that the light is never red and green at the same time. It’s not a very interesting property, but it’s a good one.</p>
<pre><code>  &gt; data Color = Red | Green | Yellow deriving (Show, Eq)
  &gt; ts = TransitionSystem [Red] [(Red, Green), (Green, Yellow), (Yellow, Red)] only</code></pre>
<p>In this case, our set of atomic propositions is just <code>Red</code>, <code>Green</code>, and <code>Yellow</code>, which is the same as our set of states! The label of each state <code>s</code> is <code>only s</code>, meaning that only that color is <code>True</code>. In other words, in the state <code>Red</code>, <code>Red</code> is <code>True</code>, <code>Green</code> is <code>False</code>, and <code>Yellow</code> is <code>False</code>. That’s why we use the <code>only</code> function as our labeling function; it simply labels each state with the assignment that sets that color to <code>True</code>, and everything else to <code>False</code>:</p>
<pre><code>  &gt; tsLabel ts Red Red     -- is Red true in state Red?
  True
  &gt; tsLabel ts Red Green   -- is Green true in state Red?
  False
  &gt; tsLabel ts Green Green -- is Green true in state Green?
  True</code></pre>
<p>Now, we would like to know that <code>Red</code> and <code>Green</code> are never true at the same time. It’s trivial to see why this is true, because by construction, there isn’t a state in our transition system that satisfies both <code>Red</code> and <code>Green</code>.</p>
<p>We can use our <code>checkInvariant</code> function to check that our invariant holds:</p>
<pre><code>  &gt; checkInvariant (not (atom Red .&amp; atom Green)) ts
  Nothing</code></pre>
<p>The result <code>Nothing</code> means there were no counterexamples, which means our invariant holds! Let’s try it with an invariant that doesn’t hold:</p>
<pre><code>  &gt; checkInvariant (not (atom Yellow)) ts
  Just Yellow</code></pre>
<p>Our invariant checking algorithm was able to reach a state that violated <code>not (atom Yellow)</code>; unsurprisingly, it was the <code>Yellow</code> state. Because <code>Yellow</code> is reachable in our transition system, our property doesn’t hold. What if, however, <code>Yellow</code> is not reachable?</p>
<pre><code>  &gt; ts = TransitionSystem [Red] [(Red, Green), (Green, Red)] only
  &gt; checkInvariant (not (atom Yellow)) ts
  Nothing</code></pre>
<h2 id="conclusion">Conclusion</h2>
<p>At this point, you’re probably thinking: “That’s it?” Well, no! That’s definitely not it. There’s tons more things to talk about, and we will be getting deeper into the world of model checking in subsequent posts.</p>
<p>There’s two basic dimensions that will become deeper. The first dimension is about <em>how</em> we create a transition system from a more high-level artifact. Many of the artifacts we’re interested in modeling involve multiple, concurrent processes that interact in interesting ways, and we’ll need to expand our machinery to construct appropriate transition systems in order to succesfully model these artifacts.</p>
<p>The second dimension involves the kinds of properties we can state. Invariants are great, but they’re <em>dead</em> simple. They don’t let you talk about how different states relate to each other, and they also don’t let you talk about eventuality (“at some point in the future, this thing will happen”). In future posts, we’ll explore how to state, and verify, more complex properties of this sort.</p>
<p>Hopefully, this first post gave you a taste of what model checking is all about. In the next post, we’ll explore the second dimension a little bit by expanding the kinds of properties we can state and verify. We’ll define the notion of a <em>regular safety property</em>, which is a generalization of invariants that allows us to talk about relationships between states.</p>
