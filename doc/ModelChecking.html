<h1 id="introduction-to-model-checking-with-haskell">Introduction to model checking (with Haskell!)</h1>
<p>Recently, I’ve been reading a <a href="https://www.amazon.com/Principles-Model-Checking-MIT-Press/dp/026202649X/ref=sr_1_1?crid=2RGC1B0N79HIJ&amp;keywords=principles+of+model+checking&amp;qid=1651762001&amp;sprefix=principles+of+model+checking%2Caps%2C134&amp;sr=8-1">book</a> and watching a <a href="https://www.youtube.com/watch?v=Y5Hg4MvUXc4&amp;list=PLwabKnOFhE38C0o6z_bhlF_uOUlblDTjh">lecture series</a> about model checking. This is a topic I’ve learned a bit about in the past, but never really studied in earnest.</p>
<p>This literate haskell document is an attempt to translate some of my learnings into the world of Haskell. I hope it provides a brief and illustrative introduction to the topic for other Haskell programmers who are curious about the topic. This is for learning purposes only; I deliberately avoided putting any effort into making things efficient. I’m really using Haskell as a convenient notation to express the ideas.</p>
<p>Preamble:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">module</span> <span class="dt">ModelChecking</span> <span class="kw">where</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Data.List</span> (union, (\\), nub, find)</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Prelude</span> <span class="kw">hiding</span> (not, (*))</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Prelude</span> <span class="kw">as</span> <span class="dt">P</span></span></code></pre></div>
<h2 id="transition-systems">Transition systems</h2>
<p>So, what are the models we are checking? They are called <em>transition systems</em>. A transition system is basically a directed graph, where the vertices of the graph represent possible program states, and the edges represent transitions from one state to another. The transitions are followed nondeterministically; when a state has multiple outgoing transitions, that simply means that it can follow any of them.</p>
<p>Along with the states (vertices) and transitions (directed edges), a transition system has one additional ingredient: a set of <em>atomic propositional variables</em> that are either true or false in each state. In Haskell, we represent these variables as a type (or a type variable <code>ap</code>), and we formalize the notion of an <em>assignment</em> of variables as a function from this type to <code>Bool</code>:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- | An assignment is an evaluation of a set of boolean variables.</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">Assignment</span> ap <span class="ot">=</span> ap <span class="ot">-&gt;</span> <span class="dt">Bool</span></span></code></pre></div>
<p>It’s often convenient to “lift” a propositional variable <code>p</code> to the assignment which sets <code>p</code> to <code>True</code>, and everything else to <code>False</code>, so we define a function to accomplish this here:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="ot">only ::</span> <span class="dt">Eq</span> ap <span class="ot">=&gt;</span> ap <span class="ot">-&gt;</span> <span class="dt">Assignment</span> ap</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>only <span class="ot">=</span> (<span class="op">==</span>)</span></code></pre></div>
<p>The idea is that every state in our transition system is <em>labeled</em> with an assignment, identifying which atomic propositions are true or false in each state. We can now define a transition system in Haskell:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">TransitionSystem</span> s ap <span class="ot">=</span> <span class="dt">TransitionSystem</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>  {<span class="ot"> tsInitials ::</span> [s]</span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a>  ,<span class="ot"> tsTransitions ::</span> [(s, s)]</span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a>  ,<span class="ot"> tsLabel ::</span> s <span class="ot">-&gt;</span> <span class="dt">Assignment</span> ap</span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a>  }</span></code></pre></div>
<p>The initial states are represented as a list, the transitions as an association list (mathematically, a relation), and the labels as a function from states to <code>Assignment</code>s of the atomic propositions <code>ap</code>. As stated in the introduction, this is by no means a good representation if your goal is efficiency; the point here is to make the concepts as easy to understand as possible.</p>
<h2 id="propositions">Propositions</h2>
<p>Each state in our transition system has a corresponding variable assignment. The idea is</p>
<p>type Proposition ap = Assignment ap -&gt; Bool</p>
<p>– | Propositional satisfaction. (|=) :: Assignment ap -&gt; Proposition ap -&gt; Bool f |= p = p f</p>
<p>– | Atomic proposition. atom :: ap -&gt; Proposition ap atom ap f = f ap</p>
<p>– | Conjunction of two propositions. (.&amp;) :: Proposition ap -&gt; Proposition ap -&gt; Proposition ap (p .&amp; q) f = (f |= p) &amp;&amp; (f |= q)</p>
<p>– | Disjunction of two propositions. (.|) :: Proposition ap -&gt; Proposition ap -&gt; Proposition ap (p .| q) f = (f |= p) || (f |= q)</p>
<p>– | Propositional negation. not :: Proposition ap -&gt; Proposition ap not p f = P.not (f |= p)</p>
<p>– | Propositional implication. (.-&gt;) :: Proposition ap -&gt; Proposition ap -&gt; Proposition ap p .-&gt; q = not p .| q</p>
<p>dfs :: Eq s =&gt; [s] -&gt; [(s, s)] -&gt; [s] dfs starts = go [] starts where go visited [] _ = nub visited go visited starts transitions = let nexts = [ s’’ | s &lt;- starts, (s’, s’‘) &lt;- transitions, s == s’ ] \ visited in go (visited ++ starts) nexts transitions</p>
<p>– | Check that an invariant holds for a (finite) transition system. This simply – does a depth-first search of the transition system, searching for a reachable – state that fails to satisfy the invariant. checkInvariant :: Eq s =&gt; Proposition ap -&gt; TransitionSystem s ap -&gt; Maybe s checkInvariant inv ts = find (-&gt; P.not (tsLabel ts s |= inv)) (dfs (tsInitials ts) [ (s, s’) | (s, s’) &lt;- tsTransitions ts ])</p>
<p>ex :: TransitionSystem Int Int ex = TransitionSystem { tsInitials = [0] , tsTransitions = [ (x, (x+2) <code>mod</code> 9) | x &lt;- [0..8]] , tsLabel = only }</p>
<p>data NFA q ap = NFA { nfaTransitions :: [(q, Proposition ap, q)] , nfaInitials :: [q] , nfaFinals :: [q] }</p>
<p>nextStatesOn :: NFA q ap -&gt; q -&gt; Assignment ap -&gt; [q] nextStatesOn nfa q f = [ q’ | (q, p, q’) &lt;- nfaTransitions nfa, f |= p ]</p>
<p>– | Product of a transition system and an NFA. (<em>) :: Eq q =&gt; TransitionSystem s ap -&gt; NFA q ap -&gt; TransitionSystem (s, q) q ts </em> nfa = TransitionSystem { tsTransitions = [ ((s, q), (s’, q’)) | (s, s’) &lt;- tsTransitions ts , (q, p, q’) &lt;- nfaTransitions nfa , tsLabel ts s’ |= p ] , tsInitials = [ (s, q) | s &lt;- tsInitials ts , q0 &lt;- nfaInitials nfa , q &lt;- nextStatesOn nfa q0 (tsLabel ts s) ] , tsLabel = (s, q) -&gt; only q }</p>
<p>data Color = Red | Yellow | Green deriving (Eq, Show)</p>
<p>traffic_light :: TransitionSystem Color Color traffic_light = TransitionSystem { tsInitials = [Green] , tsTransitions = [ (Red, Green), (Green, Yellow) , (Yellow, Red), (Green, Red) ] , tsLabel = -&gt; only color }</p>
<p>yellow_before_red :: NFA Int Color yellow_before_red = NFA { nfaInitials = [0] , nfaFinals = [1] , nfaTransitions = [ (0, atom Green, 0) , (0, atom Yellow, 1) , (0, atom Red, 2) , (2, atom Yellow, 2) , (2, not (atom Yellow), 0) ] }</p>
