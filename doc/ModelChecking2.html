<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>Model Checking in Haskell, Part 2: From Programs to Transition Systems</title>
  <style>
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    span.underline{text-decoration: underline;}
    div.column{display: inline-block; vertical-align: top; width: 50%;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    ul.task-list{list-style: none;}
    pre > code.sourceCode { white-space: pre; position: relative; }
    pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
    pre > code.sourceCode > span:empty { height: 1.2em; }
    .sourceCode { overflow: visible; }
    code.sourceCode > span { color: inherit; text-decoration: inherit; }
    div.sourceCode { margin: 1em 0; }
    pre.sourceCode { margin: 0; }
    @media screen {
    div.sourceCode { overflow: auto; }
    }
    @media print {
    pre > code.sourceCode { white-space: pre-wrap; }
    pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
    }
    pre.numberSource code
      { counter-reset: source-line 0; }
    pre.numberSource code > span
      { position: relative; left: -4em; counter-increment: source-line; }
    pre.numberSource code > span > a:first-child::before
      { content: counter(source-line);
        position: relative; left: -1em; text-align: right; vertical-align: baseline;
        border: none; display: inline-block;
        -webkit-touch-callout: none; -webkit-user-select: none;
        -khtml-user-select: none; -moz-user-select: none;
        -ms-user-select: none; user-select: none;
        padding: 0 4px; width: 4em;
        color: #aaaaaa;
      }
    pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
    div.sourceCode
      {   }
    @media screen {
    pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
    }
    code span.al { color: #ff0000; font-weight: bold; } /* Alert */
    code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
    code span.at { color: #7d9029; } /* Attribute */
    code span.bn { color: #40a070; } /* BaseN */
    code span.bu { } /* BuiltIn */
    code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
    code span.ch { color: #4070a0; } /* Char */
    code span.cn { color: #880000; } /* Constant */
    code span.co { color: #60a0b0; font-style: italic; } /* Comment */
    code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
    code span.do { color: #ba2121; font-style: italic; } /* Documentation */
    code span.dt { color: #902000; } /* DataType */
    code span.dv { color: #40a070; } /* DecVal */
    code span.er { color: #ff0000; font-weight: bold; } /* Error */
    code span.ex { } /* Extension */
    code span.fl { color: #40a070; } /* Float */
    code span.fu { color: #06287e; } /* Function */
    code span.im { } /* Import */
    code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
    code span.kw { color: #007020; font-weight: bold; } /* Keyword */
    code span.op { color: #666666; } /* Operator */
    code span.ot { color: #007020; } /* Other */
    code span.pp { color: #bc7a00; } /* Preprocessor */
    code span.sc { color: #4070a0; } /* SpecialChar */
    code span.ss { color: #bb6688; } /* SpecialString */
    code span.st { color: #4070a0; } /* String */
    code span.va { color: #19177c; } /* Variable */
    code span.vs { color: #4070a0; } /* VerbatimString */
    code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
    .display.math{display: block; text-align: center; margin: 0.5rem auto;}
  </style>
  <link rel="stylesheet" href="../css/pandoc.css" />
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
<header id="title-block-header">
<h1 class="title">Model Checking in Haskell, Part 2: From Programs to Transition Systems</h1>
</header>
<nav id="TOC" role="doc-toc">
<ul>
<li><a href="#a-simple-imperative-programming-language">A simple imperative programming language</a>
<ul>
<li><a href="#the-modify-statement">The <code>Modify</code> statement</a></li>
<li><a href="#the-ifgoto-statement">The <code>IfGoto</code> statement</a></li>
<li><a href="#implementing-factorial">Implementing factorial</a></li>
</ul></li>
<li><a href="#from-sequential-programs-to-transition-systems">From sequential programs to transition systems</a>
<ul>
<li><a href="#atomic-propositions">Atomic propositions</a></li>
<li><a href="#converting-the-factorial-program-to-a-transition-system">Converting the factorial program to a transition system</a></li>
<li><a href="#thats-it-for-sequential-programs">That’s it for sequential programs</a></li>
</ul></li>
<li><a href="#parallel-programs">Parallel programs</a>
<ul>
<li><a href="#petersons-algorithm">Peterson’s algorithm</a></li>
</ul></li>
<li><a href="#from-parallel-programs-to-transition-systems">From parallel programs to transition systems</a>
<ul>
<li><a href="#model-checking-petersons-algorithm">Model checking Peterson’s algorithm</a></li>
</ul></li>
<li><a href="#conclusion">Conclusion</a></li>
</ul>
</nav>
<p>In the <a href="ModelChecking1.html">previous post</a>, we introduced transition systems, which are directed graphs that capture how the state of a system can evolve through time. Each state in the graph was labeled with a <em>true-set</em>, the set of all atomic propositions which are true in that state. We explored how to build logical propositions in terms of the atomic propositions of the state labels, and how to check that such a proposition is an <em>invariant</em> of the transition system. By using an off-the-shelf graph search algorithm, we discovered all reachable states and evaluated the proposition at each state.</p>
<p>In this post, we will take a look at how transition systems can be derived from computer programs. We will develop a very simple imperative programming language, and then we will write a function that converts programs written in this language to transition systems. We’ll also look at a few examples of such programs, and we’ll show how to apply our <code>checkInvariant</code> function from the previous post to these examples to check important properties.</p>
<h1 id="a-simple-imperative-programming-language">A simple imperative programming language</h1>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">module</span> <span class="dt">ModelChecking2</span> <span class="kw">where</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">ModelChecking1</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Data.Map.Strict</span> (<span class="dt">Map</span>)</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Data.Map.Strict</span> <span class="kw">as</span> <span class="dt">Map</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Data.Vector</span> (<span class="dt">Vector</span>)</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Data.Vector</span> <span class="kw">as</span> <span class="dt">Vec</span></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Data.Void</span></span></code></pre></div>
<p>In this section, we’ll define a simple, Turing-complete imperative language with variable assignments and conditional gotos. The language will be implemented as a <em>shallowly-embedded domain-specific language (eDSL)</em> in Haskell; we won’t be writing a lexer or parser, and we won’t even be writing an expression or statement evaluator, because expressions and statements in our language constructs will <em>themselves</em> be functions which directly evaluate and modify (respectively) the environment.</p>
<p>In our language, a program is a sequence of statements. There are two kinds of statements:</p>
<ol type="1">
<li><code>Modify</code>: modify the global variable environment (e.g. assign a variable to a value)</li>
<li><code>IfGoto</code>: test a condition; if it’s true, go to the given line number</li>
</ol>
<p>The <em>global variable environment</em>, or just <em>environment</em>, is an assignment of values to a set of variables. It doesn’t particularly matter what the variables and values are, so we’ll abstract them with type variables <code>var</code> and <code>val</code>, respectively. The environment is going to be a <code>Map</code> from <code>var</code>s to <code>val</code>s:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">Env</span> var val <span class="ot">=</span> <span class="dt">Map</span> var val</span></code></pre></div>
<p>A statement that modifies the global variable environment is represented as an <em>effect</em>, which is a function taking the old environment to a new one:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">Effect</span> var val <span class="ot">=</span> <span class="dt">Env</span> var val <span class="ot">-&gt;</span> <span class="dt">Env</span> var val</span></code></pre></div>
<p>A statement that <em>branches</em> needs to change the current line number. We’ll use <code>Int</code> as a sensible type for our line numbers:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">LineNumber</span> <span class="ot">=</span> <span class="dt">Int</span></span></code></pre></div>
<p>A statement in our language either modifies the current environment, or conditionally goes to the given line number:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Stmt</span> var val <span class="ot">=</span> <span class="dt">Modify</span> (<span class="dt">Effect</span> var val)</span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>                  <span class="op">|</span> <span class="dt">IfGoto</span> (<span class="dt">Predicate</span> (<span class="dt">Env</span> var val)) <span class="dt">LineNumber</span></span></code></pre></div>
<p>To execute a <code>Modify</code> statement, we simply apply the <code>Effect</code> to the current environment, thus modifying it, and then go to the next line in the program. To execute an <code>IfGoto</code> statement, we first test the <code>Predicate</code> against the current environment: if the predicate evaluates to true, then we go to the <code>LineNumber</code> indicated; if it is not true, then we go to the next line in the program.</p>
<p>We’ll also need an unconditional <code>goto</code> statement. We’ll define it as <code>IfGoto true</code>, where <code>true :: Predicate a</code> (defined in the previous post) is the function that always returns <code>True</code>:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="ot">goto ::</span> <span class="dt">LineNumber</span> <span class="ot">-&gt;</span> <span class="dt">Stmt</span> var val</span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a>goto lineNum <span class="ot">=</span> <span class="dt">IfGoto</span> true lineNum</span></code></pre></div>
<p>A program is just a <code>Vector</code> of statements:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">Prog</span> var val <span class="ot">=</span> <span class="dt">Vector</span> (<span class="dt">Stmt</span> var val)</span></code></pre></div>
<h2 id="the-modify-statement">The <code>Modify</code> statement</h2>
<p>In this section and the next section, we will define some helper functions that will make it easier to create readable statements in our language. In this section, we focus on <code>Modify</code>; in the next, we’ll look at <code>IfGoto</code>.</p>
<p>The <code>Modify</code> constructor takes a single argument, an <code>Effect</code>:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="dt">Modify</span><span class="ot"> ::</span> <span class="dt">Effect</span> var val <span class="ot">-&gt;</span> <span class="dt">Stmt</span> var val</span></code></pre></div>
<p>Recall that an <em>effect</em> is a function that modifies the global variable environment:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">Effect</span> var val <span class="ot">=</span> <span class="dt">Env</span> var val <span class="ot">-&gt;</span> <span class="dt">Env</span> var val</span></code></pre></div>
<p>In C, we might see a line like this:</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> x = y * <span class="dv">4</span>;</span></code></pre></div>
<p>The left-hand side of the <code>=</code> is a variable, and the right-hand side is an <em>expression</em> that can be evaluated, given an environment that has a definition for the variable <code>y</code>. In our language, we could write the corresponding <code>Modify</code> statement like so:</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">XY</span> <span class="ot">=</span> <span class="dt">X</span> <span class="op">|</span> <span class="dt">Y</span> <span class="kw">deriving</span> (<span class="dt">Show</span>, <span class="dt">Eq</span>, <span class="dt">Ord</span>)</span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a><span class="ot">modify_stmt ::</span> <span class="dt">Stmt</span> <span class="dt">XY</span> <span class="dt">Int</span></span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a>modify_stmt <span class="ot">=</span> <span class="dt">Modify</span> (\env <span class="ot">-&gt;</span> Map.insert <span class="dt">X</span> (env <span class="op">Map.!</span> <span class="dt">Y</span> <span class="op">*</span> <span class="dv">4</span>) env)</span></code></pre></div>
<p>The function we passed to <code>Modify</code> took the current environment and modified it by looking up the value of <code>Y</code>, adding <code>4</code> to it, and setting <code>X</code> equal to the result. This is okay, but it would be much nicer to write something that looked more like the corresponding C statement.</p>
<p>To accomplish this, we’ll define an <em>assignment</em> operator that works on single variables. The operator will be <code>.=</code>, and the syntax</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a>x <span class="op">.=</span> e</span></code></pre></div>
<p>will mean “evaluate the expression <code>e</code> and assign the result to the variable <code>x</code>”. A simple way to represent an <em>expression</em> is as a function from the environment to a particular value:</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">Expr</span> var val <span class="ot">=</span> <span class="dt">Env</span> var val <span class="ot">-&gt;</span> val</span></code></pre></div>
<p>Then, the assignment operator can be written as</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a><span class="ot">(.=) ::</span> <span class="dt">Ord</span> var <span class="ot">=&gt;</span> var <span class="ot">-&gt;</span> <span class="dt">Expr</span> var val <span class="ot">-&gt;</span> <span class="dt">Effect</span> var val</span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a>(x <span class="op">.=</span> e) env <span class="ot">=</span> Map.insert x (e env) env</span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true" tabindex="-1"></a>infix <span class="dv">2</span> <span class="op">.=</span></span></code></pre></div>
<p>This allows us to create an <code>Effect</code>, which is a function, without writing an explicit lambda or defining the function in a <code>let</code> or <code>where</code> clause. Now, we can define the <code>x_equals_4_y</code> statement a bit more nicely:</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a><span class="ot">modify_stmt ::</span> <span class="dt">Stmt</span> <span class="dt">XY</span> <span class="dt">Int</span></span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a>modify_stmt <span class="ot">=</span> <span class="dt">Modify</span> (<span class="dt">X</span> <span class="op">.=</span> (\env <span class="ot">-&gt;</span> env <span class="op">Map.!</span> <span class="dt">Y</span> <span class="op">*</span> <span class="dv">4</span>))</span></code></pre></div>
<p>This is better. However, the <code>Expr</code> we are binding <code>X</code> to is still defined in terms of a lambda expression and an explicit <code>Map.!</code> operator. We can do a bit better still by defining some more functions to build <code>Expr</code>s more cleanly. We’ll create “atomic” expressions from variables and values, and combine expressions using numeric operators. We will also be able to “lift” ordinary functions into our language. This is made especially easy because we chose a shallow embedding approach.</p>
<p>If <code>x :: var</code> is a variable, we can create a corresponding expression for <code>x</code>. In our representation, the <em>expression</em> for <code>x</code> will be a function that simply looks up <code>x</code> in the environment and returns its value. The function <code>var</code> “lifts” any variable to its corresponding expression.</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a><span class="ot">var ::</span> <span class="dt">Ord</span> var <span class="ot">=&gt;</span> var <span class="ot">-&gt;</span> <span class="dt">Expr</span> var val</span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a>var x env <span class="ot">=</span> env <span class="op">Map.!</span> x</span></code></pre></div>
<p>If <code>c :: val</code> is a constant value, we can create a corresponding expression for <code>c</code>. In our representation, the <em>expression</em> for <code>c</code> will be a function that ignores the current environment and blindly returns the value <code>c</code>. The function <code>val</code> “lifts” a constant value to its corresponding expression.</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a><span class="ot">val ::</span> val <span class="ot">-&gt;</span> <span class="dt">Expr</span> var val</span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a>val c _ <span class="ot">=</span> c</span></code></pre></div>
<p>If <code>val</code> is a numeric type, we can lift the usual numeric operators to expressions:</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a><span class="ot">(.+) ::</span> <span class="dt">Num</span> val <span class="ot">=&gt;</span> <span class="dt">Expr</span> var val <span class="ot">-&gt;</span> <span class="dt">Expr</span> var val <span class="ot">-&gt;</span> <span class="dt">Expr</span> var val</span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a>(e1 <span class="op">.+</span> e2) env <span class="ot">=</span> e1 env <span class="op">+</span> e2 env</span>
<span id="cb18-3"><a href="#cb18-3" aria-hidden="true" tabindex="-1"></a><span class="kw">infixl</span> <span class="dv">6</span> <span class="op">.+</span></span></code></pre></div>
<div class="sourceCode" id="cb19"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a><span class="ot">(.-) ::</span> <span class="dt">Num</span> val <span class="ot">=&gt;</span> <span class="dt">Expr</span> var val <span class="ot">-&gt;</span> <span class="dt">Expr</span> var val <span class="ot">-&gt;</span> <span class="dt">Expr</span> var val</span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true" tabindex="-1"></a>(e1 <span class="op">.-</span> e2) env <span class="ot">=</span> e1 env <span class="op">-</span> e2 env</span>
<span id="cb19-3"><a href="#cb19-3" aria-hidden="true" tabindex="-1"></a><span class="kw">infixl</span> <span class="dv">6</span> <span class="op">.-</span></span></code></pre></div>
<div class="sourceCode" id="cb20"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a><span class="ot">(.*) ::</span> <span class="dt">Num</span> val <span class="ot">=&gt;</span> <span class="dt">Expr</span> var val <span class="ot">-&gt;</span> <span class="dt">Expr</span> var val <span class="ot">-&gt;</span> <span class="dt">Expr</span> var val</span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true" tabindex="-1"></a>(e1 <span class="op">.*</span> e2) env <span class="ot">=</span> e1 env <span class="op">*</span> e2 env</span>
<span id="cb20-3"><a href="#cb20-3" aria-hidden="true" tabindex="-1"></a><span class="kw">infixl</span> <span class="dv">7</span> <span class="op">.*</span></span></code></pre></div>
<p>Furthermore, if a function <code>f : val -&gt; val</code> transforms values, we can lift <code>f</code> to a function that transforms expressions:</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a><span class="ot">liftFun ::</span> (val <span class="ot">-&gt;</span> val) <span class="ot">-&gt;</span> <span class="dt">Expr</span> var val <span class="ot">-&gt;</span> <span class="dt">Expr</span> var val</span>
<span id="cb21-2"><a href="#cb21-2" aria-hidden="true" tabindex="-1"></a>liftFun f e env <span class="ot">=</span> f (e env)</span></code></pre></div>
<p>Now, let’s quickly play around in ghci to get a feel:</p>
<div class="sourceCode" id="cb22"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true" tabindex="-1"></a>  <span class="op">&gt;</span> <span class="kw">data</span> <span class="dt">XY</span> <span class="ot">=</span> <span class="dt">X</span> <span class="op">|</span> <span class="dt">Y</span> <span class="kw">deriving</span> (<span class="dt">Show</span>, <span class="dt">Eq</span>, <span class="dt">Ord</span>)</span>
<span id="cb22-2"><a href="#cb22-2" aria-hidden="true" tabindex="-1"></a>  <span class="op">&gt;</span> <span class="op">:</span>t var <span class="dt">X</span></span>
<span id="cb22-3"><a href="#cb22-3" aria-hidden="true" tabindex="-1"></a>  var <span class="dt">X</span><span class="ot"> ::</span> <span class="dt">Expr</span> <span class="dt">XY</span> val</span>
<span id="cb22-4"><a href="#cb22-4" aria-hidden="true" tabindex="-1"></a>  <span class="op">&gt;</span> <span class="op">:</span>t (var <span class="dt">X</span> <span class="op">.+</span> val <span class="dv">1</span>) <span class="op">.-</span> var <span class="dt">Y</span></span>
<span id="cb22-5"><a href="#cb22-5" aria-hidden="true" tabindex="-1"></a>  (var <span class="dt">X</span> <span class="op">.+</span> var <span class="dv">1</span>) <span class="op">.-</span> var <span class="dt">Y</span><span class="ot"> ::</span> <span class="dt">Num</span> val <span class="ot">=&gt;</span> <span class="dt">Expr</span> <span class="dt">XY</span> val</span>
<span id="cb22-6"><a href="#cb22-6" aria-hidden="true" tabindex="-1"></a>  <span class="op">&gt;</span> <span class="op">:</span>t liftFun (<span class="op">+</span><span class="dv">1</span>) (var <span class="dt">X</span>)</span>
<span id="cb22-7"><a href="#cb22-7" aria-hidden="true" tabindex="-1"></a>  liftFun (<span class="op">+</span><span class="dv">1</span>) (var <span class="dt">X</span>)<span class="ot"> ::</span> <span class="dt">Num</span> val <span class="ot">=&gt;</span> <span class="dt">Expr</span> <span class="dt">XY</span> val</span></code></pre></div>
<p>To evaluate an expression, we just <em>apply</em> it (as a function) to an environment:</p>
<div class="sourceCode" id="cb23"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true" tabindex="-1"></a>  <span class="op">&gt;</span> <span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Data.Map</span> <span class="kw">as</span> <span class="dt">Map</span></span>
<span id="cb23-2"><a href="#cb23-2" aria-hidden="true" tabindex="-1"></a>  <span class="op">&gt;</span> (var <span class="dt">X</span> <span class="op">.+</span> val <span class="dv">1</span>) <span class="op">.-</span> var <span class="dt">Y</span> <span class="op">$</span> Map.fromList [(<span class="dt">X</span>, <span class="dv">4</span>), (<span class="dt">Y</span>, <span class="op">-</span><span class="dv">2</span>)]</span>
<span id="cb23-3"><a href="#cb23-3" aria-hidden="true" tabindex="-1"></a>  <span class="dv">7</span></span>
<span id="cb23-4"><a href="#cb23-4" aria-hidden="true" tabindex="-1"></a>  <span class="op">&gt;</span> liftFun (<span class="op">+</span><span class="dv">1</span>) (var <span class="dt">X</span>) <span class="op">$</span> Map.fromList [(<span class="dt">X</span>, <span class="dv">4</span>), (<span class="dt">Y</span>, <span class="op">-</span><span class="dv">2</span>)]</span>
<span id="cb23-5"><a href="#cb23-5" aria-hidden="true" tabindex="-1"></a>  <span class="dv">5</span></span></code></pre></div>
<p>Now, we can rewrite our <code>int x = y * 4;</code> statement in a much nicer way:</p>
<div class="sourceCode" id="cb24"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb24-1"><a href="#cb24-1" aria-hidden="true" tabindex="-1"></a><span class="ot">modify_stmt ::</span> <span class="dt">Stmt</span> <span class="dt">XY</span> <span class="dt">Int</span></span>
<span id="cb24-2"><a href="#cb24-2" aria-hidden="true" tabindex="-1"></a>modify_stmt <span class="ot">=</span> <span class="dt">Modify</span> (<span class="dt">X</span> <span class="op">.=</span> var <span class="dt">Y</span> <span class="op">.*</span> <span class="dv">4</span>)</span></code></pre></div>
<p>If we have <em>two</em> effects that we’d like to perform, one after another, we can combine them with the following operator:</p>
<div class="sourceCode" id="cb25"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb25-1"><a href="#cb25-1" aria-hidden="true" tabindex="-1"></a><span class="ot">(!:) ::</span> <span class="dt">Effect</span> var val <span class="ot">-&gt;</span> <span class="dt">Effect</span> var val <span class="ot">-&gt;</span> <span class="dt">Effect</span> var val</span>
<span id="cb25-2"><a href="#cb25-2" aria-hidden="true" tabindex="-1"></a>(a <span class="op">!:</span> b) env <span class="ot">=</span> b (a env)</span>
<span id="cb25-3"><a href="#cb25-3" aria-hidden="true" tabindex="-1"></a><span class="kw">infixr</span> <span class="dv">1</span> <span class="op">!:</span></span></code></pre></div>
<p>If <code>a</code> and <code>b</code> are effects, <code>a !: b</code> is the effect which results from first performing <code>a</code>, then performing <code>b</code>.</p>
<div class="sourceCode" id="cb26"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb26-1"><a href="#cb26-1" aria-hidden="true" tabindex="-1"></a>  <span class="op">&gt;</span> <span class="op">:</span>t <span class="dt">X</span> <span class="op">.=</span> var <span class="dt">Y</span> <span class="op">!:</span> <span class="dt">Y</span> <span class="op">.=</span> var <span class="dt">Y</span> <span class="op">.+</span> val <span class="dv">1</span></span>
<span id="cb26-2"><a href="#cb26-2" aria-hidden="true" tabindex="-1"></a>  <span class="dt">X</span> <span class="op">.=</span> var <span class="dt">Y</span> <span class="op">!:</span> <span class="dt">Y</span> <span class="op">.=</span> var <span class="dt">Y</span> <span class="op">.+</span> val <span class="dv">1</span></span>
<span id="cb26-3"><a href="#cb26-3" aria-hidden="true" tabindex="-1"></a><span class="ot">    ::</span> <span class="dt">Num</span> val <span class="ot">=&gt;</span> <span class="dt">Env</span> <span class="dt">XY</span> val <span class="ot">-&gt;</span> <span class="dt">Env</span> <span class="dt">XY</span> val</span>
<span id="cb26-4"><a href="#cb26-4" aria-hidden="true" tabindex="-1"></a>  <span class="op">&gt;</span> (<span class="dt">X</span> <span class="op">.=</span> var <span class="dt">Y</span>) <span class="op">!:</span> (<span class="dt">Y</span> <span class="op">.=</span> var <span class="dt">Y</span> <span class="op">.+</span> val <span class="dv">1</span>) <span class="op">$</span> Map.fromList [(<span class="dt">X</span>, <span class="dv">1</span>), (<span class="dt">Y</span>, <span class="dv">2</span>)]</span>
<span id="cb26-5"><a href="#cb26-5" aria-hidden="true" tabindex="-1"></a>  fromList [(<span class="dt">X</span>,<span class="dv">2</span>),(<span class="dt">Y</span>,<span class="dv">3</span>)]</span></code></pre></div>
<h2 id="the-ifgoto-statement">The <code>IfGoto</code> statement</h2>
<p>In this section, we’ll define a few helper functions to help us write <code>IfGoto</code> statements in a readable way. The <code>IfGoto</code> takes an <em>environment predicate</em> and a line number as arguments:</p>
<div class="sourceCode" id="cb27"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb27-1"><a href="#cb27-1" aria-hidden="true" tabindex="-1"></a><span class="dt">IfGoto</span><span class="ot"> ::</span> <span class="dt">Predicate</span> (<span class="dt">Env</span> var val) <span class="ot">-&gt;</span> <span class="dt">LineNumber</span> <span class="ot">-&gt;</span> <span class="dt">Stmt</span> var val</span></code></pre></div>
<p>Recall from the previous post that a predicate is just a single-argument function that returns a <code>Bool</code>:</p>
<div class="sourceCode" id="cb28"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb28-1"><a href="#cb28-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">Predicate</span> a <span class="ot">=</span> a <span class="ot">-&gt;</span> <span class="dt">Bool</span></span></code></pre></div>
<p>Therefore, a <code>Predicate (Env var val)</code> is a function <code>Env var val -&gt; Bool</code>. If this function evaluates to <code>True</code> in the current environment, the line number should change to the value specified by the second argument of <code>IfGoto</code>, the <code>LineNumber</code>.</p>
<p>In C, we might see a conditional <code>goto</code> statement like this:</p>
<div class="sourceCode" id="cb29"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb29-1"><a href="#cb29-1" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> (x == <span class="dv">1</span> + y) <span class="cf">goto</span> label;</span></code></pre></div>
<p>Ideally the programmer doesn’t use explicit <code>goto</code>s, but in our language it will be the only option for affecting control flow in our programs. In our language, assuming <code>label</code> refers to line 17, we can write the corresponding <code>IfGoto</code> statement like so:</p>
<div class="sourceCode" id="cb30"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb30-1"><a href="#cb30-1" aria-hidden="true" tabindex="-1"></a><span class="ot">if_goto_stmt ::</span> <span class="dt">Stmt</span> <span class="dt">XY</span> <span class="dt">Int</span></span>
<span id="cb30-2"><a href="#cb30-2" aria-hidden="true" tabindex="-1"></a>if_goto_stmt <span class="ot">=</span> <span class="dt">IfGoto</span> (\env <span class="ot">-&gt;</span> env <span class="op">Map.!</span> <span class="dt">X</span> <span class="op">==</span> <span class="dv">1</span> <span class="op">+</span> env <span class="op">Map.!</span> <span class="dt">Y</span>) <span class="dv">17</span></span></code></pre></div>
<p>The function we passed to <code>IfGoto</code> took the current environment, looked up the values of <code>X</code> and <code>Y</code>, and tested whether the value of <code>X</code> was equal to <code>1</code> plus the value of <code>Y</code>. As with <code>Modify</code>, we’ll write some helper functions to create these environment predicates in a way that more closely resembles the original <code>C</code> code. The first such function will be the equality operator, which evaluates two expressions and determines if they are equal:</p>
<div class="sourceCode" id="cb31"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb31-1"><a href="#cb31-1" aria-hidden="true" tabindex="-1"></a><span class="ot">(.==) ::</span> <span class="dt">Eq</span> val <span class="ot">=&gt;</span> <span class="dt">Expr</span> var val <span class="ot">-&gt;</span> <span class="dt">Expr</span> var val <span class="ot">-&gt;</span> <span class="dt">Predicate</span> (<span class="dt">Env</span> var val)</span>
<span id="cb31-2"><a href="#cb31-2" aria-hidden="true" tabindex="-1"></a>(e1 <span class="op">.==</span> e2) env <span class="ot">=</span> e1 env <span class="op">==</span> e2 env</span>
<span id="cb31-3"><a href="#cb31-3" aria-hidden="true" tabindex="-1"></a>infix <span class="dv">4</span> <span class="op">.==</span></span></code></pre></div>
<p>The next functions we’ll need are the inequality operators:</p>
<div class="sourceCode" id="cb32"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb32-1"><a href="#cb32-1" aria-hidden="true" tabindex="-1"></a><span class="ot">(.&lt;=) ::</span> <span class="dt">Ord</span> val <span class="ot">=&gt;</span> <span class="dt">Expr</span> var val <span class="ot">-&gt;</span> <span class="dt">Expr</span> var val <span class="ot">-&gt;</span> <span class="dt">Predicate</span> (<span class="dt">Env</span> var val)</span>
<span id="cb32-2"><a href="#cb32-2" aria-hidden="true" tabindex="-1"></a>(e1 <span class="op">.&lt;=</span> e2) env <span class="ot">=</span> e1 env <span class="op">&lt;=</span> e2 env</span>
<span id="cb32-3"><a href="#cb32-3" aria-hidden="true" tabindex="-1"></a>infix <span class="dv">4</span> <span class="op">.&lt;=</span></span></code></pre></div>
<div class="sourceCode" id="cb33"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb33-1"><a href="#cb33-1" aria-hidden="true" tabindex="-1"></a><span class="ot">(.&lt;) ::</span> <span class="dt">Ord</span> val <span class="ot">=&gt;</span> <span class="dt">Expr</span> var val <span class="ot">-&gt;</span> <span class="dt">Expr</span> var val <span class="ot">-&gt;</span> <span class="dt">Predicate</span> (<span class="dt">Env</span> var val)</span>
<span id="cb33-2"><a href="#cb33-2" aria-hidden="true" tabindex="-1"></a>(e1 <span class="op">.&lt;</span> e2) env <span class="ot">=</span> e1 env <span class="op">&lt;</span> e2 env</span>
<span id="cb33-3"><a href="#cb33-3" aria-hidden="true" tabindex="-1"></a>infix <span class="dv">4</span> <span class="op">.&lt;</span></span></code></pre></div>
<div class="sourceCode" id="cb34"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb34-1"><a href="#cb34-1" aria-hidden="true" tabindex="-1"></a><span class="ot">(.&gt;=) ::</span> <span class="dt">Ord</span> val <span class="ot">=&gt;</span> <span class="dt">Expr</span> var val <span class="ot">-&gt;</span> <span class="dt">Expr</span> var val <span class="ot">-&gt;</span> <span class="dt">Predicate</span> (<span class="dt">Env</span> var val)</span>
<span id="cb34-2"><a href="#cb34-2" aria-hidden="true" tabindex="-1"></a>(e1 <span class="op">.&gt;=</span> e2) env <span class="ot">=</span> e1 env <span class="op">&gt;=</span> e2 env</span>
<span id="cb34-3"><a href="#cb34-3" aria-hidden="true" tabindex="-1"></a>infix <span class="dv">4</span> <span class="op">.&gt;=</span></span></code></pre></div>
<div class="sourceCode" id="cb35"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb35-1"><a href="#cb35-1" aria-hidden="true" tabindex="-1"></a><span class="ot">(.&gt;) ::</span> <span class="dt">Ord</span> val <span class="ot">=&gt;</span> <span class="dt">Expr</span> var val <span class="ot">-&gt;</span> <span class="dt">Expr</span> var val <span class="ot">-&gt;</span> <span class="dt">Predicate</span> (<span class="dt">Env</span> var val)</span>
<span id="cb35-2"><a href="#cb35-2" aria-hidden="true" tabindex="-1"></a>(e1 <span class="op">.&gt;</span> e2) env <span class="ot">=</span> e1 env <span class="op">&gt;</span> e2 env</span>
<span id="cb35-3"><a href="#cb35-3" aria-hidden="true" tabindex="-1"></a>infix <span class="dv">4</span> <span class="op">.&gt;</span></span></code></pre></div>
<p>We can also lift predicates about <code>val</code>s to environment predicates by supplying them with an expression:</p>
<div class="sourceCode" id="cb36"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb36-1"><a href="#cb36-1" aria-hidden="true" tabindex="-1"></a><span class="ot">liftPred ::</span> <span class="dt">Predicate</span> val <span class="ot">-&gt;</span> <span class="dt">Expr</span> var val <span class="ot">-&gt;</span> <span class="dt">Predicate</span> (<span class="dt">Env</span> var val)</span>
<span id="cb36-2"><a href="#cb36-2" aria-hidden="true" tabindex="-1"></a>liftPred f e env <span class="ot">=</span> f (e env)</span></code></pre></div>
<p>Also note that we can combine predicates using the boolean operators <code>.&amp;</code>, <code>.|</code>, <code>pnot</code>, and <code>.-&gt;</code> as defined in the previous post; these enable us to “build up” larger predicates out of smaller ones:</p>
<div class="sourceCode" id="cb37"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb37-1"><a href="#cb37-1" aria-hidden="true" tabindex="-1"></a>  <span class="op">&gt;</span> <span class="op">:</span>t (val <span class="dv">1</span> <span class="op">.&lt;=</span> var <span class="dt">X</span>) <span class="op">.&amp;</span> (var <span class="dt">X</span> <span class="op">.&lt;=</span> var <span class="dt">Y</span>)</span>
<span id="cb37-2"><a href="#cb37-2" aria-hidden="true" tabindex="-1"></a>  (val <span class="dv">1</span> <span class="op">.&lt;=</span> var <span class="dt">X</span>) <span class="op">.&amp;</span> (var <span class="dt">X</span> <span class="op">.&lt;=</span> var <span class="dt">Y</span>)</span>
<span id="cb37-3"><a href="#cb37-3" aria-hidden="true" tabindex="-1"></a><span class="ot">  ::</span> (<span class="dt">Ord</span> val, <span class="dt">Num</span> val) <span class="ot">=&gt;</span> <span class="dt">Predicate</span> (<span class="dt">Env</span> <span class="dt">XY</span> val)</span></code></pre></div>
<p>Now, we can implement the C statement <code>if (x == 1 + y) goto label;</code> in a much nicer way:</p>
<div class="sourceCode" id="cb38"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb38-1"><a href="#cb38-1" aria-hidden="true" tabindex="-1"></a><span class="ot">if_goto_stmt ::</span> <span class="dt">Stmt</span> <span class="dt">XY</span> <span class="dt">Int</span></span>
<span id="cb38-2"><a href="#cb38-2" aria-hidden="true" tabindex="-1"></a>if_goto_stmt <span class="ot">=</span> <span class="dt">IfGoto</span> (var <span class="dt">X</span> <span class="op">.==</span> val <span class="dv">1</span> <span class="op">.+</span> var <span class="dt">Y</span>) <span class="dv">17</span></span></code></pre></div>
<h2 id="implementing-factorial">Implementing factorial</h2>
<p>Now, let’s implement the factorial function, just to illustrate how the different language constructs work. We’re going to hand-translate this C function:</p>
<div class="sourceCode" id="cb39"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb39-1"><a href="#cb39-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> fact(<span class="dt">int</span> n) {</span>
<span id="cb39-2"><a href="#cb39-2" aria-hidden="true" tabindex="-1"></a>  <span class="dt">int</span> i = <span class="dv">2</span>, res = <span class="dv">1</span>;</span>
<span id="cb39-3"><a href="#cb39-3" aria-hidden="true" tabindex="-1"></a>  <span class="cf">while</span> (i &lt;= n) {</span>
<span id="cb39-4"><a href="#cb39-4" aria-hidden="true" tabindex="-1"></a>    res *= i;</span>
<span id="cb39-5"><a href="#cb39-5" aria-hidden="true" tabindex="-1"></a>    i += <span class="dv">1</span>;</span>
<span id="cb39-6"><a href="#cb39-6" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb39-7"><a href="#cb39-7" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> res;</span>
<span id="cb39-8"><a href="#cb39-8" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div>
<p>into a program written in the above, two-statement language. The program has two variables, <code>n</code> and <code>res</code>:</p>
<div class="sourceCode" id="cb40"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb40-1"><a href="#cb40-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">FactVar</span> <span class="ot">=</span> <span class="dt">N</span> <span class="op">|</span> <span class="dt">I</span> <span class="op">|</span> <span class="dt">Res</span> <span class="kw">deriving</span> (<span class="dt">Show</span>, <span class="dt">Eq</span>, <span class="dt">Ord</span>)</span></code></pre></div>
<p>Now we’re ready to write the <code>fact</code> program (line numbers are listed in comments to the left of each statement):</p>
<div class="sourceCode" id="cb41"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb41-1"><a href="#cb41-1" aria-hidden="true" tabindex="-1"></a><span class="ot">fact ::</span> <span class="dt">Prog</span> <span class="dt">FactVar</span> <span class="dt">Int</span></span>
<span id="cb41-2"><a href="#cb41-2" aria-hidden="true" tabindex="-1"></a>fact <span class="ot">=</span> Vec.fromList</span>
<span id="cb41-3"><a href="#cb41-3" aria-hidden="true" tabindex="-1"></a>  <span class="co">{- 0 -}</span> [ <span class="dt">Modify</span> (<span class="dt">Res</span> <span class="op">.=</span> val <span class="dv">1</span> <span class="op">!:</span> <span class="dt">I</span> <span class="op">.=</span> val <span class="dv">2</span>)</span>
<span id="cb41-4"><a href="#cb41-4" aria-hidden="true" tabindex="-1"></a>  <span class="co">{- 1 -}</span> , <span class="dt">IfGoto</span> (pnot (var <span class="dt">I</span> <span class="op">.&lt;=</span> var <span class="dt">N</span>)) <span class="dv">5</span></span>
<span id="cb41-5"><a href="#cb41-5" aria-hidden="true" tabindex="-1"></a>  <span class="co">{- 2 -}</span> ,   <span class="dt">Modify</span> (<span class="dt">Res</span> <span class="op">.=</span> (var <span class="dt">Res</span> <span class="op">.*</span> var <span class="dt">I</span>))</span>
<span id="cb41-6"><a href="#cb41-6" aria-hidden="true" tabindex="-1"></a>  <span class="co">{- 3 -}</span> ,   <span class="dt">Modify</span> (<span class="dt">I</span>   <span class="op">.=</span> (var <span class="dt">I</span>   <span class="op">.+</span> val <span class="dv">1</span>))</span>
<span id="cb41-7"><a href="#cb41-7" aria-hidden="true" tabindex="-1"></a>  <span class="co">{- 4 -}</span> ,   goto <span class="dv">1</span></span>
<span id="cb41-8"><a href="#cb41-8" aria-hidden="true" tabindex="-1"></a>  <span class="co">{- 5 -}</span> , goto <span class="dv">5</span> <span class="co">-- halt</span></span>
<span id="cb41-9"><a href="#cb41-9" aria-hidden="true" tabindex="-1"></a>          ]</span></code></pre></div>
<p>We don’t have a separate <code>Halt</code> statement, so we model that with a <code>goto</code> statement that points to itself, infinitely looping.</p>
<h1 id="from-sequential-programs-to-transition-systems">From sequential programs to transition systems</h1>
<p>In order to model check programs, we’ll need to be able to convert a program into a transition system. The basic idea will be that a state in the transition system will be a pair <code>(LineNumber, Env var val)</code>, consisting of the current line number and the current values of the program variables. Each state will have exactly one outgoing transition, which corresponds to executing the statement at the current line of the program and then going to the next line to be executed.</p>
<p>The atomic propositional variables will be defined by the caller. The caller will provide a list of variables, along with a function mapping each variable to some predicate involving the current line number and global variable environment. Then, the label of each state will be the set of variables whose corresponding predicate is true at the current <code>(LineNumber, Env var val)</code> pair.</p>
<p>The <code>action</code> type will just be <code>LineNumber</code>, corresponding to “performing the statement at the given line.”</p>
<div class="sourceCode" id="cb42"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb42-1"><a href="#cb42-1" aria-hidden="true" tabindex="-1"></a><span class="ot">progToTS ::</span> [<span class="dt">Env</span> var val]</span>
<span id="cb42-2"><a href="#cb42-2" aria-hidden="true" tabindex="-1"></a>         <span class="ot">-&gt;</span> [ap]</span>
<span id="cb42-3"><a href="#cb42-3" aria-hidden="true" tabindex="-1"></a>         <span class="ot">-&gt;</span> (ap <span class="ot">-&gt;</span> <span class="dt">Predicate</span> (<span class="dt">LineNumber</span>, <span class="dt">Env</span> var val))</span>
<span id="cb42-4"><a href="#cb42-4" aria-hidden="true" tabindex="-1"></a>         <span class="ot">-&gt;</span> <span class="dt">Prog</span> var val</span>
<span id="cb42-5"><a href="#cb42-5" aria-hidden="true" tabindex="-1"></a>         <span class="ot">-&gt;</span> <span class="dt">TransitionSystem</span> (<span class="dt">LineNumber</span>, <span class="dt">Env</span> var val) <span class="dt">LineNumber</span> ap</span>
<span id="cb42-6"><a href="#cb42-6" aria-hidden="true" tabindex="-1"></a>progToTS initialEnvs aps apToPred prog <span class="ot">=</span> <span class="dt">TransitionSystem</span></span></code></pre></div>
<p>The first argument to this function, <code>initialEnvs</code>, is a list of possible initial environments for the program. Every program starts at line <code>0</code>. For each initial environment provided by the caller, there is a corresponding initial state in the transition system that starts the program at line <code>0</code> with that initial environment:</p>
<div class="sourceCode" id="cb43"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb43-1"><a href="#cb43-1" aria-hidden="true" tabindex="-1"></a>  { tsInitialStates <span class="ot">=</span> [ (<span class="dv">0</span>, env) <span class="op">|</span> env <span class="ot">&lt;-</span> initialEnvs ]</span></code></pre></div>
<p>Given a state <code>s :: (LineNumber, Env var val)</code>, the label of <code>s</code> is the set of all atomic propositional variables (as supplied by the caller) whose corresponding environment predicate is satisified by <code>s</code>:</p>
<div class="sourceCode" id="cb44"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb44-1"><a href="#cb44-1" aria-hidden="true" tabindex="-1"></a>  , tsLabel <span class="ot">=</span> \s <span class="ot">-&gt;</span> [ p <span class="op">|</span> p <span class="ot">&lt;-</span> aps, s <span class="op">|=</span> apToPred p ]</span></code></pre></div>
<p>Each state <code>(lineNum, env) :: (LineNumber, Env var val)</code> as a single outgoing transition.</p>
<div class="sourceCode" id="cb45"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb45-1"><a href="#cb45-1" aria-hidden="true" tabindex="-1"></a>  , tsTransitions <span class="ot">=</span> \(lineNum, env) <span class="ot">-&gt;</span> <span class="kw">case</span> prog <span class="op">Vec.!</span> lineNum <span class="kw">of</span></span></code></pre></div>
<p>The <code>Modify</code> statement transitions to the next line, and modifies the environment by applying the given effect:</p>
<div class="sourceCode" id="cb46"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb46-1"><a href="#cb46-1" aria-hidden="true" tabindex="-1"></a>      <span class="dt">Modify</span> effect <span class="ot">-&gt;</span> [(lineNum, (lineNum<span class="op">+</span><span class="dv">1</span>, effect env))]</span></code></pre></div>
<p>The <code>IfGoto</code> statement tests the environment predicate; if it’s true, we transition to the given line number, and if it’s false, we transition to the next line number. In both cases, the global variable environment is left unchanged.</p>
<div class="sourceCode" id="cb47"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb47-1"><a href="#cb47-1" aria-hidden="true" tabindex="-1"></a>      <span class="dt">IfGoto</span> p lineNum&#39;</span>
<span id="cb47-2"><a href="#cb47-2" aria-hidden="true" tabindex="-1"></a>        <span class="op">|</span> p env     <span class="ot">-&gt;</span> [(lineNum, (lineNum&#39; , env))]</span>
<span id="cb47-3"><a href="#cb47-3" aria-hidden="true" tabindex="-1"></a>        <span class="op">|</span> <span class="fu">otherwise</span> <span class="ot">-&gt;</span> [(lineNum, (lineNum<span class="op">+</span><span class="dv">1</span>, env))]</span>
<span id="cb47-4"><a href="#cb47-4" aria-hidden="true" tabindex="-1"></a>  }</span></code></pre></div>
<h2 id="atomic-propositions">Atomic propositions</h2>
<p>In translating to a transition system, we need to define our set of atomic propositional variables, which amounts to identifying a few predicates about our state which we are interested in. We also need to map each variable to its corresponding predicate when we call <code>progToTS</code>. This map needs to be a function of type <code>ap -&gt; Predicate (LineNumber, Env var val)</code>; that is, our atomic propositions will denote predicates that take the current line number into account as well as the global variable environment.</p>
<p>The following “lifting” operators will be nice to have, as they will enable us to smoothly define such predicates:</p>
<div class="sourceCode" id="cb48"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb48-1"><a href="#cb48-1" aria-hidden="true" tabindex="-1"></a><span class="ot">liftL ::</span> <span class="dt">Predicate</span> a <span class="ot">-&gt;</span> <span class="dt">Predicate</span> (a, b)</span>
<span id="cb48-2"><a href="#cb48-2" aria-hidden="true" tabindex="-1"></a>liftL p (a, _) <span class="ot">=</span> p a</span></code></pre></div>
<div class="sourceCode" id="cb49"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb49-1"><a href="#cb49-1" aria-hidden="true" tabindex="-1"></a><span class="ot">liftR ::</span> <span class="dt">Predicate</span> b <span class="ot">-&gt;</span> <span class="dt">Predicate</span> (a, b)</span>
<span id="cb49-2"><a href="#cb49-2" aria-hidden="true" tabindex="-1"></a>liftR p (_, b) <span class="ot">=</span> p b</span></code></pre></div>
<p>With these operators, we can lift a predicate about an <code>Env var val</code> to a predicate about a <code>(LineNumber, Env var val)</code> pair:</p>
<div class="sourceCode" id="cb50"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb50-1"><a href="#cb50-1" aria-hidden="true" tabindex="-1"></a><span class="ot">atEnv ::</span> <span class="dt">Predicate</span> (<span class="dt">Env</span> var val) <span class="ot">-&gt;</span> <span class="dt">Predicate</span> (a, <span class="dt">Env</span> var val)</span>
<span id="cb50-2"><a href="#cb50-2" aria-hidden="true" tabindex="-1"></a>atEnv <span class="ot">=</span> liftR</span></code></pre></div>
<p>Furthermore, we sometimes will wish to define invariants that only apply when we are at a specific line number, so the following function will be useful:</p>
<div class="sourceCode" id="cb51"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb51-1"><a href="#cb51-1" aria-hidden="true" tabindex="-1"></a><span class="ot">atLine ::</span> <span class="dt">LineNumber</span> <span class="ot">-&gt;</span> <span class="dt">Predicate</span> (<span class="dt">LineNumber</span>, a)</span>
<span id="cb51-2"><a href="#cb51-2" aria-hidden="true" tabindex="-1"></a>atLine lineNum <span class="ot">=</span> liftL (<span class="op">==</span> lineNum)</span></code></pre></div>
<h2 id="converting-the-factorial-program-to-a-transition-system">Converting the factorial program to a transition system</h2>
<p>In converting a program to a transition system, we first need to choose:</p>
<ol type="1">
<li>The set of all possible initial environments</li>
<li>The set of all atomic propositional variables</li>
<li>How each atomic propositional variable maps to a <em>predicate</em> about the current line number and environment</li>
</ol>
<p>In fact, these are the first three arguments of the <code>progToTS</code> function. The choices we make will depend on what kinds of properties we want to verify, and what the set of possible starting states we will want to consider.</p>
<p>For our factorial program, the property we’ll be interested in checking is a loop invariant which will hold at the beginning of the loop. Whenever the program is at line 1, the following formula should hold:</p>
<pre><code>Res == factorial(I-1)</code></pre>
<p>In other words, the current value of <code>Res</code> should be the “product so far.” We’d also like to check this loop invariant for not just one particular input value of <code>n</code>, but for a range of inputs.</p>
<p>In light of these considerations, we’ll making the following respective choices:</p>
<ol type="1">
<li><p>The set of possible initial environments will be the set of all environments with <code>N = i</code> for all <code>i</code> between <code>1</code> and some maximum integer <code>n</code>. (We’ll initialize <code>Res</code> and <code>I</code> to <code>0</code> for completeness, but we note that their initial values don’t matter, since the first line of the program sets them both to <code>1</code>.)</p></li>
<li><p>We will have two types of atomic propositional variables: ones that indicate what the current line number is, and ones that indicate whether the condition <code>Res == factorial(I-1)</code> is true.</p></li>
<li><p>We will map the variables described in 2) to the corresponding predicates about the current <code>(LineNumber, Env var val)</code> state in the transition system.</p></li>
</ol>
<p>Our atomic propositions will be of the following type:</p>
<div class="sourceCode" id="cb53"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb53-1"><a href="#cb53-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">FactProp</span> <span class="ot">=</span> <span class="dt">FactAtLine</span> <span class="dt">Int</span></span>
<span id="cb53-2"><a href="#cb53-2" aria-hidden="true" tabindex="-1"></a>              <span class="op">|</span> <span class="dt">FactResInvariant</span></span>
<span id="cb53-3"><a href="#cb53-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">deriving</span> (<span class="dt">Show</span>, <span class="dt">Eq</span>, <span class="dt">Ord</span>)</span></code></pre></div>
<p>The full set of propositions is <code>FactResInvariant</code>, plus <code>FactAtLine i</code> for every line <code>i</code> of the <code>fact</code> program:</p>
<div class="sourceCode" id="cb54"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb54-1"><a href="#cb54-1" aria-hidden="true" tabindex="-1"></a><span class="ot">factProps ::</span> [<span class="dt">FactProp</span>]</span>
<span id="cb54-2"><a href="#cb54-2" aria-hidden="true" tabindex="-1"></a>factProps <span class="ot">=</span> <span class="dt">FactResInvariant</span> <span class="op">:</span> [ <span class="dt">FactAtLine</span> i <span class="op">|</span> i <span class="ot">&lt;-</span> [<span class="dv">0</span><span class="op">..</span>Vec.length fact] ]</span></code></pre></div>
<p>We use the following mapping from <code>FactProp</code> to state predicates:</p>
<div class="sourceCode" id="cb55"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb55-1"><a href="#cb55-1" aria-hidden="true" tabindex="-1"></a><span class="ot">factPropPred ::</span> <span class="dt">FactProp</span> <span class="ot">-&gt;</span> <span class="dt">Predicate</span> (<span class="dt">LineNumber</span>, <span class="dt">Env</span> <span class="dt">FactVar</span> <span class="dt">Int</span>)</span>
<span id="cb55-2"><a href="#cb55-2" aria-hidden="true" tabindex="-1"></a>factPropPred (<span class="dt">FactAtLine</span> i) <span class="ot">=</span> atLine i</span>
<span id="cb55-3"><a href="#cb55-3" aria-hidden="true" tabindex="-1"></a>factPropPred <span class="dt">FactResInvariant</span> <span class="ot">=</span></span>
<span id="cb55-4"><a href="#cb55-4" aria-hidden="true" tabindex="-1"></a>  atEnv <span class="op">$</span> var <span class="dt">Res</span> <span class="op">.==</span> liftFun factorial (var <span class="dt">I</span> <span class="op">.-</span> val <span class="dv">1</span>)</span>
<span id="cb55-5"><a href="#cb55-5" aria-hidden="true" tabindex="-1"></a>  <span class="kw">where</span> factorial n <span class="ot">=</span> <span class="fu">product</span> [<span class="dv">1</span><span class="op">..</span>n]</span></code></pre></div>
<p>Now, we define <code>factTS</code> in terms of the above:</p>
<div class="sourceCode" id="cb56"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb56-1"><a href="#cb56-1" aria-hidden="true" tabindex="-1"></a><span class="ot">factTS ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">TransitionSystem</span> (<span class="dt">LineNumber</span>, <span class="dt">Env</span> <span class="dt">FactVar</span> <span class="dt">Int</span>) <span class="dt">LineNumber</span> <span class="dt">FactProp</span></span>
<span id="cb56-2"><a href="#cb56-2" aria-hidden="true" tabindex="-1"></a>factTS n <span class="ot">=</span> progToTS initialEnvs factProps factPropPred fact</span>
<span id="cb56-3"><a href="#cb56-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">where</span> initialEnvs <span class="ot">=</span> [ Map.fromList [(<span class="dt">N</span>, i), (<span class="dt">Res</span>, <span class="dv">0</span>), (<span class="dt">I</span>, <span class="dv">0</span>)] <span class="op">|</span> i <span class="ot">&lt;-</span> [<span class="dv">1</span><span class="op">..</span>n] ]</span></code></pre></div>
<p>Let’s check our loop invariant for <code>factTS</code> for all values of <code>n</code> from <code>1</code> to <code>20</code>:</p>
<div class="sourceCode" id="cb57"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb57-1"><a href="#cb57-1" aria-hidden="true" tabindex="-1"></a>  <span class="op">&gt;</span> checkInvariant (atom (<span class="dt">FactAtLine</span> <span class="dv">1</span>) <span class="op">.-&gt;</span> atom <span class="dt">FactResInvariant</span>) <span class="dv">20</span></span>
<span id="cb57-2"><a href="#cb57-2" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Nothing</span></span></code></pre></div>
<p>Here’s a nice picture of <code>factTS 4</code>. Each state’s name is written in the format <code>lineNum: &lt;n=value, res=value&gt;</code>:</p>
<figure>
<img src="../images/fact.png" style="width:100.0%;height:100.0%" alt="Transition system for the fact function with inputs n = 1 through 4" /><figcaption aria-hidden="true">Transition system for the <code>fact</code> function with inputs <code>n = 1</code> through <code>4</code></figcaption>
</figure>
<h2 id="thats-it-for-sequential-programs">That’s it for sequential programs</h2>
<p>Unfortunately, there’s not much else to say about <code>fact</code>, or about any deterministic sequential program for that matter. We’re not going to be able to prove anything in general about such a program, because in order to even convert a program into a transition system, all of the variables must have concrete values; therefore, “checking an invariant” of this system will be little more than simulating the program for a particular input. For instance, suppose we wanted to make sure that at each loop iteration, <code>Res * N! == n!</code>, where <code>n</code> is the original input value and <code>N</code> is the current value of the <code>N</code> variable. We could certainly do this:</p>
<p>This is nice, because it doesn’t just check that result of the program is correct; it actually shows that for input <code>4</code>, the values of <code>N</code> and <code>Res</code> are consistent at every loop iteration. However, it’s still deeply unsatisfying because it doesn’t say anything about arbitrary <code>N</code>.</p>
<p>This is less of an issue with parallel programs, which are inherently nondeterministic; therefore, we’ll focus on parallel programs and protocols for the rest of this blog series. In the next section, we’ll look at parallel programs that operate on a shared state, and we’ll model check a simple mutual exclusion protocol.</p>
<h1 id="parallel-programs">Parallel programs</h1>
<p>A <em>parallel program</em> is just an array of programs:</p>
<div class="sourceCode" id="cb58"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb58-1"><a href="#cb58-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">ParProg</span> var val <span class="ot">=</span> <span class="dt">Vector</span> (<span class="dt">Prog</span> var val)</span></code></pre></div>
<h2 id="petersons-algorithm">Peterson’s algorithm</h2>
<h1 id="from-parallel-programs-to-transition-systems">From parallel programs to transition systems</h1>
<h2 id="model-checking-petersons-algorithm">Model checking Peterson’s algorithm</h2>
<h1 id="conclusion">Conclusion</h1>
</body>
</html>
