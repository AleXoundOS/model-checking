<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>Model Checking in Haskell, Part 2: From Programs to Transition Systems</title>
  <style>
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    span.underline{text-decoration: underline;}
    div.column{display: inline-block; vertical-align: top; width: 50%;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    ul.task-list{list-style: none;}
    pre > code.sourceCode { white-space: pre; position: relative; }
    pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
    pre > code.sourceCode > span:empty { height: 1.2em; }
    .sourceCode { overflow: visible; }
    code.sourceCode > span { color: inherit; text-decoration: inherit; }
    div.sourceCode { margin: 1em 0; }
    pre.sourceCode { margin: 0; }
    @media screen {
    div.sourceCode { overflow: auto; }
    }
    @media print {
    pre > code.sourceCode { white-space: pre-wrap; }
    pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
    }
    pre.numberSource code
      { counter-reset: source-line 0; }
    pre.numberSource code > span
      { position: relative; left: -4em; counter-increment: source-line; }
    pre.numberSource code > span > a:first-child::before
      { content: counter(source-line);
        position: relative; left: -1em; text-align: right; vertical-align: baseline;
        border: none; display: inline-block;
        -webkit-touch-callout: none; -webkit-user-select: none;
        -khtml-user-select: none; -moz-user-select: none;
        -ms-user-select: none; user-select: none;
        padding: 0 4px; width: 4em;
        color: #aaaaaa;
      }
    pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
    div.sourceCode
      {   }
    @media screen {
    pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
    }
    code span.al { color: #ff0000; font-weight: bold; } /* Alert */
    code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
    code span.at { color: #7d9029; } /* Attribute */
    code span.bn { color: #40a070; } /* BaseN */
    code span.bu { } /* BuiltIn */
    code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
    code span.ch { color: #4070a0; } /* Char */
    code span.cn { color: #880000; } /* Constant */
    code span.co { color: #60a0b0; font-style: italic; } /* Comment */
    code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
    code span.do { color: #ba2121; font-style: italic; } /* Documentation */
    code span.dt { color: #902000; } /* DataType */
    code span.dv { color: #40a070; } /* DecVal */
    code span.er { color: #ff0000; font-weight: bold; } /* Error */
    code span.ex { } /* Extension */
    code span.fl { color: #40a070; } /* Float */
    code span.fu { color: #06287e; } /* Function */
    code span.im { } /* Import */
    code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
    code span.kw { color: #007020; font-weight: bold; } /* Keyword */
    code span.op { color: #666666; } /* Operator */
    code span.ot { color: #007020; } /* Other */
    code span.pp { color: #bc7a00; } /* Preprocessor */
    code span.sc { color: #4070a0; } /* SpecialChar */
    code span.ss { color: #bb6688; } /* SpecialString */
    code span.st { color: #4070a0; } /* String */
    code span.va { color: #19177c; } /* Variable */
    code span.vs { color: #4070a0; } /* VerbatimString */
    code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
    .display.math{display: block; text-align: center; margin: 0.5rem auto;}
  </style>
  <link rel="stylesheet" href="../css/pandoc.css" />
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
<header id="title-block-header">
<h1 class="title">Model Checking in Haskell, Part 2: From Programs to Transition Systems</h1>
</header>
<nav id="TOC" role="doc-toc">
<ul>
<li><a href="#a-simple-imperative-programming-language">A simple imperative programming language</a>
<ul>
<li><a href="#building-effects">Building effects</a></li>
<li><a href="#building-environment-predicates">Building environment predicates</a></li>
<li><a href="#an-example-sequential-program">An example (sequential) program</a></li>
</ul></li>
<li><a href="#from-sequential-programs-to-transition-systems">From sequential programs to transition systems</a></li>
<li><a href="#parallel-programs">Parallel programs</a>
<ul>
<li><a href="#petersons-algorithm">Peterson’s algorithm</a></li>
</ul></li>
<li><a href="#from-parallel-programs-to-transition-systems">From parallel programs to transition systems</a>
<ul>
<li><a href="#model-checking-petersons-algorithm">Model checking Peterson’s algorithm</a></li>
</ul></li>
<li><a href="#conclusion">Conclusion</a></li>
</ul>
</nav>
<p>In the <a href="ModelChecking1.html">previous post</a>, we introduced transition systems, which are directed graphs that capture how the state of a system can evolve through time. Each state in the graph was labeled with a <em>true-set</em>, the set of all atomic propositions which are true in that state. We explored how to build logical propositions in terms of the atomic propositions of the state labels, and how to check that such a proposition is an <em>invariant</em> of the transition system. By using an off-the-shelf graph search algorithm, we discovered all reachable states and evaluated the proposition at each state.</p>
<p>In this post, we will take a look at how transition systems can be derived from computer programs. We will develop a very simple imperative programming language, and then we will write a function that converts programs written in this language to transition systems. We’ll also look at a few examples of such programs, and we’ll show how to apply our <code>checkInvariant</code> function from the previous post to these examples to check important properties.</p>
<h1 id="a-simple-imperative-programming-language">A simple imperative programming language</h1>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">module</span> <span class="dt">ModelChecking2</span> <span class="kw">where</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">ModelChecking1</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Data.Map.Strict</span> (<span class="dt">Map</span>)</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Data.Map.Strict</span> <span class="kw">as</span> <span class="dt">Map</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Data.Vector</span> (<span class="dt">Vector</span>)</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Data.Vector</span> <span class="kw">as</span> <span class="dt">Vec</span></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Data.Void</span></span></code></pre></div>
<p>In this section, we’ll define a simple, Turing-complete imperative language with variable assignments and conditional gotos. The language will be implemented as a <em>shallowly embedded domain-specific language (eDSL)</em> in Haskell; we won’t be writing a lexer or parser, and we won’t even be writing an expression or statement evaluator, because expressions and statements in our language constructs will <em>themselves</em> be functions which directly evaluate and modify (respectively) the environment.</p>
<p>In our language, a program is a sequence of commands, each of which does one of the following two things:</p>
<ol type="1">
<li>Modify the global variable environment</li>
<li>Test a condition; if it’s true, go to the given line number</li>
</ol>
<p>The <em>global variable environment</em>, or just <em>environment</em>, is an assignment of values to a set of variables. It doesn’t particularly matter what the variables and values are, so we’ll abstract them with type variables <code>var</code> and <code>val</code>, respectively. The environment is going to be a <code>Map</code> from <code>var</code>s to <code>val</code>s:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">Env</span> var val <span class="ot">=</span> <span class="dt">Map</span> var val</span></code></pre></div>
<p>A command that modifies the global variable environment is represented as an <em>effect</em>, which is a function taking the old environment to a new one:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">Effect</span> var val <span class="ot">=</span> <span class="dt">Env</span> var val <span class="ot">-&gt;</span> <span class="dt">Env</span> var val</span></code></pre></div>
<p>A command that <em>branches</em> needs to change the current line number. We’ll use <code>Int</code> as a sensible type for our line numbers:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">LineNumber</span> <span class="ot">=</span> <span class="dt">Int</span></span></code></pre></div>
<p>A statement in our language either modifies the current environment, or conditionally goes to the given line number:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Stmt</span> var val <span class="ot">=</span> <span class="dt">Modify</span> (<span class="dt">Effect</span> var val)</span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>                  <span class="op">|</span> <span class="dt">CondGoto</span> (<span class="dt">Predicate</span> (<span class="dt">Env</span> var val)) <span class="dt">LineNumber</span></span></code></pre></div>
<p>To execute a <code>Modify</code> statement, we simply apply the <code>Effect</code> to the current environment, thus modifying it, and then go to the next line in the program. To execute a <code>CondGoto</code> statement, we first test the <code>Predicate</code> against the current environment: if the predicate evaluates to true, then we go to the <code>LineNumber</code> indicated; if it is not true, then we go to the next line in the program.</p>
<p>We’ll also need an unconditional <code>goto</code> statement. We’ll define it as <code>CondGoto true</code>, where <code>true :: Predicate a</code> is the function that always returns <code>True</code>:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="ot">goto ::</span> <span class="dt">LineNumber</span> <span class="ot">-&gt;</span> <span class="dt">Stmt</span> var val</span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a>goto lineNum <span class="ot">=</span> <span class="dt">CondGoto</span> true lineNum</span></code></pre></div>
<p>A program is just an array (here, a <code>Vector</code>) of statements:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">Prog</span> var val <span class="ot">=</span> <span class="dt">Vector</span> (<span class="dt">Stmt</span> var val)</span></code></pre></div>
<h2 id="building-effects">Building effects</h2>
<p>In this section, we’ll write a few helper functions to create <code>Effect</code>s; in the next one, we’ll do the same for <code>Predicate</code>s. They will help us create easy-to-read programs in our language.</p>
<p>Recall that an <em>effect</em> is a function that modifies the global variable environment. Since the <code>Env</code> is just a map from variables to values, the simplest way to modify the environment is to change a single variable’s value. Let’s define an <em>assignment</em> operator that works on single variables. The operator will be <code>.=</code>, and the syntax</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a>x <span class="op">.=</span> e</span></code></pre></div>
<p>will mean “assign the value of expression <code>e</code> to the variable <code>x</code>”. A simple way to represent an <em>expression</em> is as a function from the environment to a particular value:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">Expr</span> var val <span class="ot">=</span> <span class="dt">Env</span> var val <span class="ot">-&gt;</span> val</span></code></pre></div>
<p>If <code>x :: var</code> is a variable, we can use <code>x</code> as an expression. In our representation of expressions, the <em>expression</em> <code>x</code> will be a function that simply looks up the variable in the environment.</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="ot">var ::</span> <span class="dt">Ord</span> var <span class="ot">=&gt;</span> var <span class="ot">-&gt;</span> <span class="dt">Expr</span> var val</span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a>var x env <span class="ot">=</span> env <span class="op">Map.!</span> x</span></code></pre></div>
<p>If <code>c :: val</code> is a constant value, we can use <code>c</code> as an expression. In our representation, the <em>expression</em> <code>c</code> will be a function that ignores the current environment and returns the value <code>c</code>.</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="ot">val ::</span> val <span class="ot">-&gt;</span> <span class="dt">Expr</span> var val</span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a>val c _ <span class="ot">=</span> c</span></code></pre></div>
<p>If <code>val</code> is a numeric type, we can build up expressions using numeric operators:</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="ot">(.+) ::</span> <span class="dt">Num</span> val <span class="ot">=&gt;</span> <span class="dt">Expr</span> var val <span class="ot">-&gt;</span> <span class="dt">Expr</span> var val <span class="ot">-&gt;</span> <span class="dt">Expr</span> var val</span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a>(e1 <span class="op">.+</span> e2) env <span class="ot">=</span> e1 env <span class="op">+</span> e2 env</span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a><span class="kw">infixl</span> <span class="dv">6</span> <span class="op">.+</span></span></code></pre></div>
<div class="sourceCode" id="cb13"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span class="ot">(.-) ::</span> <span class="dt">Num</span> val <span class="ot">=&gt;</span> <span class="dt">Expr</span> var val <span class="ot">-&gt;</span> <span class="dt">Expr</span> var val <span class="ot">-&gt;</span> <span class="dt">Expr</span> var val</span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a>(e1 <span class="op">.-</span> e2) env <span class="ot">=</span> e1 env <span class="op">-</span> e2 env</span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a><span class="kw">infixl</span> <span class="dv">6</span> <span class="op">.-</span></span></code></pre></div>
<div class="sourceCode" id="cb14"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a><span class="ot">(.*) ::</span> <span class="dt">Num</span> val <span class="ot">=&gt;</span> <span class="dt">Expr</span> var val <span class="ot">-&gt;</span> <span class="dt">Expr</span> var val <span class="ot">-&gt;</span> <span class="dt">Expr</span> var val</span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a>(e1 <span class="op">.*</span> e2) env <span class="ot">=</span> e1 env <span class="op">*</span> e2 env</span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true" tabindex="-1"></a><span class="kw">infixl</span> <span class="dv">7</span> <span class="op">.*</span></span></code></pre></div>
<p>Now, let’s quickly play around in ghci to get a feel:</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a>  <span class="op">&gt;</span> <span class="kw">data</span> <span class="dt">XY</span> <span class="ot">=</span> <span class="dt">X</span> <span class="op">|</span> <span class="dt">Y</span> <span class="kw">deriving</span> (<span class="dt">Show</span>, <span class="dt">Eq</span>, <span class="dt">Ord</span>)</span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a>  <span class="op">&gt;</span> <span class="op">:</span>t var <span class="dt">X</span></span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true" tabindex="-1"></a>  var <span class="dt">X</span><span class="ot"> ::</span> <span class="dt">Expr</span> <span class="dt">XY</span> val</span>
<span id="cb15-4"><a href="#cb15-4" aria-hidden="true" tabindex="-1"></a>  <span class="op">&gt;</span> <span class="op">:</span>t (var <span class="dt">X</span> <span class="op">.+</span> val <span class="dv">1</span>) <span class="op">.-</span> var <span class="dt">Y</span></span>
<span id="cb15-5"><a href="#cb15-5" aria-hidden="true" tabindex="-1"></a>  (var <span class="dt">X</span> <span class="op">.+</span> var <span class="dv">1</span>) <span class="op">.-</span> var <span class="dt">Y</span><span class="ot"> ::</span> <span class="dt">Num</span> val <span class="ot">=&gt;</span> <span class="dt">Expr</span> <span class="dt">XY</span> val</span></code></pre></div>
<p>To evaluate an expression, just supply it with a concrete environment:</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a>  <span class="op">&gt;</span> <span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Data.Map</span> <span class="kw">as</span> <span class="dt">Map</span></span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a>  <span class="op">&gt;</span> (var <span class="dt">X</span> <span class="op">.+</span> val <span class="dv">1</span>) <span class="op">.-</span> var <span class="dt">Y</span> <span class="op">$</span> Map.fromList [(<span class="dt">X</span>, <span class="dv">4</span>), (<span class="dt">Y</span>, <span class="op">-</span><span class="dv">2</span>)]</span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true" tabindex="-1"></a>  <span class="dv">7</span></span></code></pre></div>
<p>Now, we can finally define <code>.=</code>, our variable assignment operator:</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a><span class="ot">(.=) ::</span> <span class="dt">Ord</span> var <span class="ot">=&gt;</span> var <span class="ot">-&gt;</span> <span class="dt">Expr</span> var val <span class="ot">-&gt;</span> <span class="dt">Effect</span> var val</span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a>(x <span class="op">.=</span> e) env <span class="ot">=</span> Map.insert x (e env) env</span>
<span id="cb17-3"><a href="#cb17-3" aria-hidden="true" tabindex="-1"></a>infix <span class="dv">2</span> <span class="op">.=</span></span></code></pre></div>
<p>In other words, <code>x .= e</code> is the function which, given an environment, evaluates the expression <code>e</code> in that environment to get a value <code>v</code>, and then sets <code>x</code>’s value to <code>v</code> in the environment. Again, let’s check it out with ghci:</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a>  <span class="op">&gt;</span> <span class="op">:</span>t <span class="dt">X</span> <span class="op">.=</span> var <span class="dt">Y</span> <span class="op">.*</span> var <span class="dt">Y</span></span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a>  <span class="dt">X</span> <span class="op">.=</span> var <span class="dt">Y</span> <span class="op">.*</span> var <span class="dt">Y</span><span class="ot"> ::</span> <span class="dt">Num</span> val <span class="ot">=&gt;</span> <span class="dt">Effect</span> <span class="dt">XY</span> val</span>
<span id="cb18-3"><a href="#cb18-3" aria-hidden="true" tabindex="-1"></a>  <span class="op">&gt;</span> <span class="dt">X</span> <span class="op">.=</span> var <span class="dt">Y</span> <span class="op">.*</span> var <span class="dt">Y</span> <span class="op">$</span> Map.fromList [(<span class="dt">X</span>, <span class="dv">4</span>), (<span class="dt">Y</span>, <span class="op">-</span><span class="dv">2</span>)]</span>
<span id="cb18-4"><a href="#cb18-4" aria-hidden="true" tabindex="-1"></a>  fromList [(<span class="dt">X</span>,<span class="op">-</span><span class="dv">4</span>),(<span class="dt">Y</span>,<span class="op">-</span><span class="dv">2</span>)]</span></code></pre></div>
<p>We can combine two effects with the <code>&gt;&gt;&gt;</code> operator (flipped function composition) from <code>Control.Arrow</code>:</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a>  <span class="op">&gt;</span> <span class="kw">import</span> <span class="dt">Control.Arrow</span> ((&gt;&gt;&gt;))</span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true" tabindex="-1"></a>  <span class="op">&gt;</span> <span class="op">:</span>t (<span class="dt">X</span> <span class="op">.=</span> var <span class="dt">Y</span>) <span class="op">&gt;&gt;&gt;</span> (<span class="dt">Y</span> <span class="op">.=</span> var <span class="dt">Y</span> <span class="op">.+</span> val <span class="dv">1</span>)</span>
<span id="cb19-3"><a href="#cb19-3" aria-hidden="true" tabindex="-1"></a>  <span class="dt">X</span> <span class="op">.=</span> var <span class="dt">Y</span> <span class="op">&gt;&gt;&gt;</span> <span class="dt">Y</span> <span class="op">.=</span> var <span class="dt">Y</span> <span class="op">.+</span> val <span class="dv">1</span></span>
<span id="cb19-4"><a href="#cb19-4" aria-hidden="true" tabindex="-1"></a><span class="ot">    ::</span> <span class="dt">Num</span> val <span class="ot">=&gt;</span> <span class="dt">Env</span> <span class="dt">XY</span> val <span class="ot">-&gt;</span> <span class="dt">Env</span> <span class="dt">XY</span> val</span>
<span id="cb19-5"><a href="#cb19-5" aria-hidden="true" tabindex="-1"></a>  <span class="op">&gt;</span> (<span class="dt">X</span> <span class="op">.=</span> var <span class="dt">Y</span>) <span class="op">&gt;&gt;&gt;</span> (<span class="dt">Y</span> <span class="op">.=</span> var <span class="dt">Y</span> <span class="op">.+</span> val <span class="dv">1</span>) <span class="op">$</span> Map.fromList [(<span class="dt">X</span>, <span class="dv">1</span>), (<span class="dt">Y</span>, <span class="dv">2</span>)]</span>
<span id="cb19-6"><a href="#cb19-6" aria-hidden="true" tabindex="-1"></a>  fromList [(<span class="dt">X</span>,<span class="dv">2</span>),(<span class="dt">Y</span>,<span class="dv">3</span>)]</span></code></pre></div>
<p>If <code>a</code> and <code>b</code> are effects, <code>a &gt;&gt;&gt; b</code> is the effect which results from first performing <code>a</code>, then performing <code>b</code>.</p>
<h2 id="building-environment-predicates">Building environment predicates</h2>
<p>Recall that our <code>CondGoto</code> constructor takes a <code>Predicate (Env var val)</code> as its first argument. This <em>environment predicate</em> is a function <code>Env var val -&gt; Bool</code> which, if it evaluates to true in the current environment, causes the line number to change to the value specified by the second argument of <code>CondGoto</code>.</p>
<p>For the time being, we’ll only need a few operators to build up these predicates. The first will be the equality operator, which evaluates two expressions and determines if they are equal:</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a><span class="ot">(.==) ::</span> <span class="dt">Eq</span> val <span class="ot">=&gt;</span> <span class="dt">Expr</span> var val <span class="ot">-&gt;</span> <span class="dt">Expr</span> var val <span class="ot">-&gt;</span> <span class="dt">Predicate</span> (<span class="dt">Env</span> var val)</span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true" tabindex="-1"></a>(e1 <span class="op">.==</span> e2) env <span class="ot">=</span> e1 env <span class="op">==</span> e2 env</span>
<span id="cb20-3"><a href="#cb20-3" aria-hidden="true" tabindex="-1"></a>infix <span class="dv">4</span> <span class="op">.==</span></span></code></pre></div>
<p>The next will be the inequality operators:</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a><span class="ot">(.&lt;=) ::</span> <span class="dt">Ord</span> val <span class="ot">=&gt;</span> <span class="dt">Expr</span> var val <span class="ot">-&gt;</span> <span class="dt">Expr</span> var val <span class="ot">-&gt;</span> <span class="dt">Predicate</span> (<span class="dt">Env</span> var val)</span>
<span id="cb21-2"><a href="#cb21-2" aria-hidden="true" tabindex="-1"></a>(e1 <span class="op">.&lt;=</span> e2) env <span class="ot">=</span> e1 env <span class="op">&lt;=</span> e2 env</span>
<span id="cb21-3"><a href="#cb21-3" aria-hidden="true" tabindex="-1"></a>infix <span class="dv">4</span> <span class="op">.&lt;=</span></span></code></pre></div>
<div class="sourceCode" id="cb22"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true" tabindex="-1"></a><span class="ot">(.&lt;) ::</span> <span class="dt">Ord</span> val <span class="ot">=&gt;</span> <span class="dt">Expr</span> var val <span class="ot">-&gt;</span> <span class="dt">Expr</span> var val <span class="ot">-&gt;</span> <span class="dt">Predicate</span> (<span class="dt">Env</span> var val)</span>
<span id="cb22-2"><a href="#cb22-2" aria-hidden="true" tabindex="-1"></a>(e1 <span class="op">.&lt;</span> e2) env <span class="ot">=</span> e1 env <span class="op">&lt;</span> e2 env</span>
<span id="cb22-3"><a href="#cb22-3" aria-hidden="true" tabindex="-1"></a>infix <span class="dv">4</span> <span class="op">.&lt;</span></span></code></pre></div>
<div class="sourceCode" id="cb23"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true" tabindex="-1"></a><span class="ot">(.&gt;=) ::</span> <span class="dt">Ord</span> val <span class="ot">=&gt;</span> <span class="dt">Expr</span> var val <span class="ot">-&gt;</span> <span class="dt">Expr</span> var val <span class="ot">-&gt;</span> <span class="dt">Predicate</span> (<span class="dt">Env</span> var val)</span>
<span id="cb23-2"><a href="#cb23-2" aria-hidden="true" tabindex="-1"></a>(e1 <span class="op">.&gt;=</span> e2) env <span class="ot">=</span> e1 env <span class="op">&gt;=</span> e2 env</span>
<span id="cb23-3"><a href="#cb23-3" aria-hidden="true" tabindex="-1"></a>infix <span class="dv">4</span> <span class="op">.&gt;=</span></span></code></pre></div>
<div class="sourceCode" id="cb24"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb24-1"><a href="#cb24-1" aria-hidden="true" tabindex="-1"></a><span class="ot">(.&gt;) ::</span> <span class="dt">Ord</span> val <span class="ot">=&gt;</span> <span class="dt">Expr</span> var val <span class="ot">-&gt;</span> <span class="dt">Expr</span> var val <span class="ot">-&gt;</span> <span class="dt">Predicate</span> (<span class="dt">Env</span> var val)</span>
<span id="cb24-2"><a href="#cb24-2" aria-hidden="true" tabindex="-1"></a>(e1 <span class="op">.&gt;</span> e2) env <span class="ot">=</span> e1 env <span class="op">&gt;</span> e2 env</span>
<span id="cb24-3"><a href="#cb24-3" aria-hidden="true" tabindex="-1"></a>infix <span class="dv">4</span> <span class="op">.&gt;</span></span></code></pre></div>
<p>These are all the basic environment predicates we’re going to need for this post, but it’s an easy enough language to extend whenever we need new effects or environment predicates. Also note that we can combine predicates using the boolean operators <code>.&amp;</code>, <code>.|</code>, <code>pnot</code>, and <code>.-&gt;</code> as defined in the previous post; these enable us to “build up” larger predicates out of smaller ones:</p>
<div class="sourceCode" id="cb25"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb25-1"><a href="#cb25-1" aria-hidden="true" tabindex="-1"></a>  <span class="op">&gt;</span> <span class="op">:</span>t (val <span class="dv">1</span> <span class="op">.&lt;=</span> var <span class="dt">X</span>) <span class="op">.&amp;</span> (var <span class="dt">X</span> <span class="op">.&lt;=</span> var <span class="dt">Y</span>)</span>
<span id="cb25-2"><a href="#cb25-2" aria-hidden="true" tabindex="-1"></a>  (val <span class="dv">1</span> <span class="op">.&lt;=</span> var <span class="dt">X</span>) <span class="op">.&amp;</span> (var <span class="dt">X</span> <span class="op">.&lt;=</span> var <span class="dt">Y</span>)</span>
<span id="cb25-3"><a href="#cb25-3" aria-hidden="true" tabindex="-1"></a><span class="ot">  ::</span> (<span class="dt">Ord</span> val, <span class="dt">Num</span> val) <span class="ot">=&gt;</span> <span class="dt">Predicate</span> (<span class="dt">Env</span> <span class="dt">XY</span> val)</span></code></pre></div>
<h2 id="an-example-sequential-program">An example (sequential) program</h2>
<p>Let’s use this language to implement the factorial function, just to illustrate how the different language constructs work.</p>
<p>We’re going to hand-translate this C function:</p>
<div class="sourceCode" id="cb26"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb26-1"><a href="#cb26-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> fact(<span class="dt">int</span> n) {</span>
<span id="cb26-2"><a href="#cb26-2" aria-hidden="true" tabindex="-1"></a>  <span class="dt">int</span> res = <span class="dv">1</span>;</span>
<span id="cb26-3"><a href="#cb26-3" aria-hidden="true" tabindex="-1"></a>  <span class="cf">while</span> (n &gt; <span class="dv">1</span>) {</span>
<span id="cb26-4"><a href="#cb26-4" aria-hidden="true" tabindex="-1"></a>    res *= n;</span>
<span id="cb26-5"><a href="#cb26-5" aria-hidden="true" tabindex="-1"></a>    n -= <span class="dv">1</span>;</span>
<span id="cb26-6"><a href="#cb26-6" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb26-7"><a href="#cb26-7" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> res;</span>
<span id="cb26-8"><a href="#cb26-8" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div>
<p>into a program written in the above, two-statement language. The program has two variables, <code>n</code> and <code>res</code>:</p>
<div class="sourceCode" id="cb27"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb27-1"><a href="#cb27-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">FactVar</span> <span class="ot">=</span> <span class="dt">N</span> <span class="op">|</span> <span class="dt">Res</span> <span class="kw">deriving</span> (<span class="dt">Show</span>, <span class="dt">Eq</span>, <span class="dt">Ord</span>)</span></code></pre></div>
<p>Now we’re ready to write the <code>fact</code> program (line numbers are listed in comments to the left of each command):</p>
<div class="sourceCode" id="cb28"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb28-1"><a href="#cb28-1" aria-hidden="true" tabindex="-1"></a><span class="ot">fact ::</span> <span class="dt">Prog</span> <span class="dt">FactVar</span> <span class="dt">Int</span></span>
<span id="cb28-2"><a href="#cb28-2" aria-hidden="true" tabindex="-1"></a>fact <span class="ot">=</span> Vec.fromList</span>
<span id="cb28-3"><a href="#cb28-3" aria-hidden="true" tabindex="-1"></a>  <span class="co">{- 0 -}</span> [ <span class="dt">Modify</span> (<span class="dt">Res</span> <span class="op">.=</span> val <span class="dv">1</span>)</span>
<span id="cb28-4"><a href="#cb28-4" aria-hidden="true" tabindex="-1"></a>  <span class="co">{- 1 -}</span> , <span class="dt">CondGoto</span> (var <span class="dt">N</span> <span class="op">.&lt;=</span> val <span class="dv">1</span>) <span class="dv">5</span></span>
<span id="cb28-5"><a href="#cb28-5" aria-hidden="true" tabindex="-1"></a>  <span class="co">{- 2 -}</span> ,   <span class="dt">Modify</span> (<span class="dt">Res</span> <span class="op">.=</span> var <span class="dt">Res</span> <span class="op">.*</span> var <span class="dt">N</span>)</span>
<span id="cb28-6"><a href="#cb28-6" aria-hidden="true" tabindex="-1"></a>  <span class="co">{- 3 -}</span> ,   <span class="dt">Modify</span> (<span class="dt">N</span>   <span class="op">.=</span> var <span class="dt">N</span>   <span class="op">.-</span> val <span class="dv">1</span>)</span>
<span id="cb28-7"><a href="#cb28-7" aria-hidden="true" tabindex="-1"></a>  <span class="co">{- 4 -}</span> ,   goto <span class="dv">1</span></span>
<span id="cb28-8"><a href="#cb28-8" aria-hidden="true" tabindex="-1"></a>  <span class="co">{- 5 -}</span> , goto <span class="dv">5</span> <span class="co">-- halt</span></span>
<span id="cb28-9"><a href="#cb28-9" aria-hidden="true" tabindex="-1"></a>          ]</span></code></pre></div>
<p>We don’t have a separate <code>Halt</code> statement, so we model that with a <code>goto</code> statement that points to itself, infinitely looping.</p>
<h1 id="from-sequential-programs-to-transition-systems">From sequential programs to transition systems</h1>
<p>In order to model check programs, we’ll need to be able to convert a program into a transition system. The basic idea will be that a state in the transition system will be a pair <code>(LineNumber, Env var val)</code>, consisting of the current line number and the current values of the program variables. Each state will have exactly one outgoing transition, which corresponds to executing the statement at the current line of the program and then going to the next line to be executed.</p>
<p>The atomic propositional variables will be defined by the caller. The caller will provide a list of variables, along with a function mapping each variable to some predicate involving the current line number and global variable environment. Then, the label of each state will be the set of variables whose corresponding predicate is true at the current <code>(LineNumber, Env var val)</code> pair.</p>
<p>The <code>action</code> type will just be <code>LineNumber</code>, corresponding to “performing the statement at the given line.”</p>
<div class="sourceCode" id="cb29"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb29-1"><a href="#cb29-1" aria-hidden="true" tabindex="-1"></a><span class="ot">progToTS ::</span> <span class="dt">Env</span> var val</span>
<span id="cb29-2"><a href="#cb29-2" aria-hidden="true" tabindex="-1"></a>         <span class="ot">-&gt;</span> [ap]</span>
<span id="cb29-3"><a href="#cb29-3" aria-hidden="true" tabindex="-1"></a>         <span class="ot">-&gt;</span> (ap <span class="ot">-&gt;</span> <span class="dt">Predicate</span> (<span class="dt">LineNumber</span>, <span class="dt">Env</span> var val))</span>
<span id="cb29-4"><a href="#cb29-4" aria-hidden="true" tabindex="-1"></a>         <span class="ot">-&gt;</span> <span class="dt">Prog</span> var val</span>
<span id="cb29-5"><a href="#cb29-5" aria-hidden="true" tabindex="-1"></a>         <span class="ot">-&gt;</span> <span class="dt">TransitionSystem</span> (<span class="dt">LineNumber</span>, <span class="dt">Env</span> var val) <span class="dt">LineNumber</span> ap</span>
<span id="cb29-6"><a href="#cb29-6" aria-hidden="true" tabindex="-1"></a>progToTS initialEnv aps apToPred prog <span class="ot">=</span> <span class="dt">TransitionSystem</span></span>
<span id="cb29-7"><a href="#cb29-7" aria-hidden="true" tabindex="-1"></a>  { tsInitialStates <span class="ot">=</span> [(<span class="dv">0</span>, initialEnv)]</span>
<span id="cb29-8"><a href="#cb29-8" aria-hidden="true" tabindex="-1"></a>  , tsLabel <span class="ot">=</span> \(lineNum, env) <span class="ot">-&gt;</span> [ p <span class="op">|</span> p <span class="ot">&lt;-</span> aps, apToPred p (lineNum, env) ]</span>
<span id="cb29-9"><a href="#cb29-9" aria-hidden="true" tabindex="-1"></a>  , tsTransitions <span class="ot">=</span> \(lineNum, env) <span class="ot">-&gt;</span> <span class="kw">case</span> prog <span class="op">Vec.!</span> lineNum <span class="kw">of</span></span>
<span id="cb29-10"><a href="#cb29-10" aria-hidden="true" tabindex="-1"></a>      <span class="dt">Modify</span> effect <span class="ot">-&gt;</span> [(lineNum, (lineNum<span class="op">+</span><span class="dv">1</span>, effect env))]</span>
<span id="cb29-11"><a href="#cb29-11" aria-hidden="true" tabindex="-1"></a>      <span class="dt">CondGoto</span> p lineNum&#39;</span>
<span id="cb29-12"><a href="#cb29-12" aria-hidden="true" tabindex="-1"></a>        <span class="op">|</span> p env     <span class="ot">-&gt;</span> [(lineNum, (lineNum&#39; , env))]</span>
<span id="cb29-13"><a href="#cb29-13" aria-hidden="true" tabindex="-1"></a>        <span class="op">|</span> <span class="fu">otherwise</span> <span class="ot">-&gt;</span> [(lineNum, (lineNum<span class="op">+</span><span class="dv">1</span>, env))]</span>
<span id="cb29-14"><a href="#cb29-14" aria-hidden="true" tabindex="-1"></a>  }</span></code></pre></div>
<p>To compute the factorial of <code>4</code>, we can build the transition system with an initial environment of <code>n = 4</code>. We aren’t interested in checking any properties, just in illustrating what the transition system looks like; therefore, we’ll use <code>Void</code> as our set of atomic propositions, since we don’t need any.</p>
<div class="sourceCode" id="cb30"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb30-1"><a href="#cb30-1" aria-hidden="true" tabindex="-1"></a><span class="ot">factTS ::</span> <span class="dt">TransitionSystem</span> (<span class="dt">LineNumber</span>, <span class="dt">Env</span> <span class="dt">FactVar</span> <span class="dt">Int</span>) <span class="dt">LineNumber</span> <span class="dt">Void</span></span>
<span id="cb30-2"><a href="#cb30-2" aria-hidden="true" tabindex="-1"></a>factTS <span class="ot">=</span> progToTS initialState [] absurd fact</span>
<span id="cb30-3"><a href="#cb30-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">where</span> initialState <span class="ot">=</span> Map.fromList [(<span class="dt">N</span>, <span class="dv">4</span>), (<span class="dt">Res</span>, <span class="dv">0</span>)]</span></code></pre></div>
<p>Here’s a nice picture of <code>factTS</code>. Each state’s name is written in the format <code>lineNum: &lt;n=value, res=value&gt;</code>:</p>
<figure>
<img src="../images/fact.png" style="width:30.0%;height:30.0%" alt="Transition system for the fact function with input n = 4" /><figcaption aria-hidden="true">Transition system for the <code>fact</code> function with input <code>n = 4</code></figcaption>
</figure>
<h1 id="parallel-programs">Parallel programs</h1>
<p>A <em>parallel program</em> is just an array of programs:</p>
<div class="sourceCode" id="cb31"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb31-1"><a href="#cb31-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">ParProg</span> var val <span class="ot">=</span> <span class="dt">Vector</span> (<span class="dt">Prog</span> var val)</span></code></pre></div>
<h2 id="petersons-algorithm">Peterson’s algorithm</h2>
<h1 id="from-parallel-programs-to-transition-systems">From parallel programs to transition systems</h1>
<h2 id="model-checking-petersons-algorithm">Model checking Peterson’s algorithm</h2>
<h1 id="conclusion">Conclusion</h1>
</body>
</html>
